<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Docker踩坑后的总结 - </title>
        <meta name="Description" content="在封装Docker镜像还有启动容器的时候，被Docker在挂载目录方面的内容坑了下，后面处理完也加深了对Docker的一些了解，在这里总结一下。"><meta property="og:title" content="Docker踩坑后的总结" />
<meta property="og:description" content="在封装Docker镜像还有启动容器的时候，被Docker在挂载目录方面的内容坑了下，后面处理完也加深了对Docker的一些了解，在这里总结一下。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" />
<meta property="article:published_time" content="2020-04-25T16:24:22+00:00" />
<meta property="article:modified_time" content="2020-04-25T16:24:22+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Docker踩坑后的总结"/>
<meta name="twitter:description" content="在封装Docker镜像还有启动容器的时候，被Docker在挂载目录方面的内容坑了下，后面处理完也加深了对Docker的一些了解，在这里总结一下。"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" /><link rel="prev" href="https://chenjunxin.com/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/" /><link rel="next" href="https://chenjunxin.com/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><meta name="google-site-verification" content="SEgZDIT-0OdxnPgHgsC3fOvdOF7O4zxgMnV25A4601U" /><meta name="baidu-site-verification" content="c694f10d0cd3c87d69a8be39bb4e7a46" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Docker踩坑后的总结",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/chenjunxin.com\/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93\/"
        },"image": {
                "@type": "ImageObject",
                "url": "https:\/\/chenjunxin.com\/cover.png",
                "width":  800 ,
                "height":  600 
            },"genre": "posts","keywords": "Docker","wordcount":  6376 ,
        "url": "https:\/\/chenjunxin.com\/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93\/","datePublished": "2020-04-25T16:24:22+00:00","dateModified": "2020-04-25T16:24:22+00:00","publisher": {
                "@type": "Organization",
                "name": "JohnnyChan",
                "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/chenjunxin.com\/logo.png",
                "width":  127 ,
                "height":  40 
                }
            },"author": {
                "@type": "Person",
                "name": "JohnnyChan"
            },"description": "在封装Docker镜像还有启动容器的时候，被Docker在挂载目录方面的内容坑了下，后面处理完也加深了对Docker的一些了解，在这里总结一下。"
    }
    </script></head>
    <body><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title=""></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title=""></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Docker踩坑后的总结</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>JohnnyChan</a></span>&nbsp;
                    <span class="post-category">收录于<a href="/categories/%E6%8A%80%E6%9C%AF/">
                                <i class="far fa-folder fa-fw"></i>技术
                            </a>&nbsp;<a href="/categories/docker/">
                                <i class="far fa-folder fa-fw"></i>Docker
                            </a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i><time datetime=2020-04-25>2020-04-25</time>&nbsp;
                <i class="fas fa-pencil-alt fa-fw"></i>约 6376 字&nbsp;
                <i class="far fa-clock fa-fw"></i>预计阅读 13 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#volume">Volume</a></li>
    <li><a href="#bind-mount">Bind Mount</a>
      <ul>
        <li><a href="#docker-又是如何做到把一个宿主机上的目录或者文件挂载到容器里面去呢">Docker 又是如何做到把一个宿主机上的目录或者文件，挂载到容器里面去呢</a></li>
        <li><a href="#-v和--mount不同点"><code>-v</code>和<code>--mount</code>不同点：</a></li>
        <li><a href="#volume与bind-mount不同点"><code>volume</code>与<code>bind mount</code>不同点:</a></li>
      </ul>
    </li>
    <li><a href="#tmpfs-mount">tmpfs mount</a></li>
    <li><a href="#docker数据挂载使用场景总结">Docker数据挂载使用场景总结</a></li>
    <li><a href="#docker-run--v-挂载数据卷异常">docker run -v 挂载数据卷异常</a></li>
  </ul>

  <ul>
    <li><a href="#docker-hub-镜像加速器">Docker Hub 镜像加速器</a>
      <ul>
        <li><a href="#配置加速地址">配置加速地址</a></li>
        <li><a href="#docker-hub-镜像加速器列表">Docker Hub 镜像加速器列表</a></li>
        <li><a href="#检查加速器是否生效">检查加速器是否生效</a></li>
        <li><a href="#docker-hub-镜像测速">Docker Hub 镜像测速</a></li>
      </ul>
    </li>
    <li><a href="#镜像的导入导出">镜像的导入导出：</a></li>
    <li><a href="#用commit-提交相关镜像生成一个新镜像">用commit 提交相关镜像生成一个新镜像：</a>
      <ul>
        <li><a href="#查看本地文件一探究竟">查看本地文件一探究竟：</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#登录你自己的仓库">登录你自己的仓库</a></li>
    <li><a href="#退出仓库">退出仓库</a></li>
  </ul>

  <ul>
    <li><a href="#创建并编辑dockerfile">创建并编辑dockerfile</a></li>
    <li><a href="#使用build命令">使用build命令</a></li>
  </ul>

  <ul>
    <li><a href="#docker-logs命令概述">docker logs命令概述</a></li>
    <li><a href="#docker-logs实例">docker logs实例</a></li>
  </ul>

  <ul>
    <li><a href="#bridge">bridge</a></li>
    <li><a href="#host">host</a></li>
    <li><a href="#none">none</a></li>
    <li><a href="#container">container</a></li>
  </ul>

  <ul>
    <li><a href="#运行相关">运行相关</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="docker数据挂载">Docker数据挂载</h1>
<p>要想将容器的内容保存在主机上，Docker有两种做法：volumn和bind mount,在Linux系统上的Docker还可以使用tmpfs mount。三种方式的差异如下图所示:
<img
        class="lazyload"
        src="/svg/loading/small.min.svg"
        data-src="https://oss.chenjunxin.com/picture/blogPicture/cec51938_types_of_mounts.webp"
        data-srcset="https://oss.chenjunxin.com/picture/blogPicture/cec51938_types_of_mounts.webp, https://oss.chenjunxin.com/picture/blogPicture/cec51938_types_of_mounts.webp 1.5x, https://oss.chenjunxin.com/picture/blogPicture/cec51938_types_of_mounts.webp 2x"
        data-sizes="auto"
        alt="https://oss.chenjunxin.com/picture/blogPicture/cec51938_types_of_mounts.webp"
        title="https://oss.chenjunxin.com/picture/blogPicture/cec51938_types_of_mounts.webp" /></p>
<ol>
<li>volume 存放在主机中由 Docker 管理的地方，在 Linux 系统上是在 <code>/var/lib/docker/volumes/</code> 路径下。非 Docker 的程序不应该修改此路径下的文件。要保存Docker中的文件资料  ，volumes 是最好的方法。</li>
<li><code>bind mount</code> 可存放在主机的任意位置的文件夹上，无论是否是 Docker 容器都可以随时修改其中的内容。</li>
<li><code>tmpfs mount</code> 只存放在内存中，不会写入系统的文件系统，即硬盘上。</li>
</ol>
<p>以下是对三种方式的进一步说明：</p>
<h2 id="volume">Volume</h2>
<p>volume(数据卷)是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li>volume可以在容器之间共享和重用</li>
<li>对volume的修改会立马生效</li>
<li>对volume的更新，不会影响镜像</li>
<li>volume默认会一直存在，即使容器被删除
注意：volume的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的volume。</li>
</ul>
<p>volume(数据卷)是由 Docker 建立与管理的，可用<code>docker volume create</code>指令直接建立，或者在建立容器或服务时一起建立。volume创建时存放在主机的目录中，将volume挂载到容器中，就是挂载该目录。一个 volume 可同時挂载到多个容器中，即使沒有运行中的容器使用此volume，它对 Docker 还是可用的，不会被自动删除。volume可以是具名或匿名 (anonymous) 的，Docker 会给匿名volume生成一个随机的目录名，然后在该目录名下的_data文件夹下，在同一个 Docker 主机中不会有重复。</p>
<p>与 volume 相关的命令為<code>docker volume</code><br>
<strong>创建一个volume</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker volume create my-vol
</code></pre></td></tr></table>
</div>
</div><p>create 之后如果不加参数，就会建立一个匿名volume，由 Docker给此 volume一個随机的名字。</p>
<p><strong>列出volume</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker volume ls
DRIVER              VOLUME NAME
<span class="nb">local</span>               fce415e10e9142e304769ff2f4cd1d45faf9fba17aaa309e4bcd7a3e53eaaaae
<span class="nb">local</span>               my-vol     
</code></pre></td></tr></table>
</div>
</div><p>前者是匿名volume，后者是具体名字的volume</p>
<p><strong>查看指定volume信息</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker volume inspect my-vol
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">&#34;CreatedAt&#34;</span>: <span class="s2">&#34;2020-04-27T09:32:52+08:00&#34;</span>,
        <span class="s2">&#34;Driver&#34;</span>: <span class="s2">&#34;local&#34;</span>,
        <span class="s2">&#34;Labels&#34;</span>: <span class="o">{}</span>,
        <span class="s2">&#34;Mountpoint&#34;</span>: <span class="s2">&#34;/var/lib/docker/volumes/my-vol/_data&#34;</span>,
        <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;my-vol&#34;</span>,
        <span class="s2">&#34;Options&#34;</span>: <span class="o">{}</span>,
        <span class="s2">&#34;Scope&#34;</span>: <span class="s2">&#34;local&#34;</span>
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>启动一个挂载volume的容器</strong><br>
在用<code>docker run</code>命令的时候，使用<code>-v</code>或者<code>--mount</code>标记来将volume 挂载到容器里。在一次 docker run 中可以挂载多个volume。<br>
下面创建一个名为<code>web</code>的容器，并加载一个volume到容器的 /webapp 目录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d -P <span class="se">\
</span><span class="se"></span>    --name web training/webapp:latest <span class="se">\
</span><span class="se"></span>    -v my-vol:/wepapp
    <span class="c1">#--mount source=my-vol,target=/webapp</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>查看volume的具体信息</strong><br>
使用以下命令可以查看<code>web</code>容器的数据卷信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker inspect web
</code></pre></td></tr></table>
</div>
</div><p>volume信息在 &ldquo;Mounts&rdquo; Key 下面</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="s2">&#34;Mounts&#34;</span>: <span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">&#34;Type&#34;</span>: <span class="s2">&#34;volume&#34;</span>,
        <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;my-vol&#34;</span>,
        <span class="s2">&#34;Source&#34;</span>: <span class="s2">&#34;/var/lib/docker/volumes/my-vol/_data&#34;</span>,
        <span class="s2">&#34;Destination&#34;</span>: <span class="s2">&#34;/app&#34;</span>,
        <span class="s2">&#34;Driver&#34;</span>: <span class="s2">&#34;local&#34;</span>,
        <span class="s2">&#34;Mode&#34;</span>: <span class="s2">&#34;&#34;</span>,
        <span class="s2">&#34;RW&#34;</span>: true,
        <span class="s2">&#34;Propagation&#34;</span>: <span class="s2">&#34;&#34;</span>
    <span class="o">}</span>
<span class="o">]</span>,
</code></pre></td></tr></table>
</div>
</div><p><strong>移除volume</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker volume rm my-vol
</code></pre></td></tr></table>
</div>
</div><p><strong>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。</strong>
如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker rm -v 容器id
</code></pre></td></tr></table>
</div>
</div><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker volume prune
</code></pre></td></tr></table>
</div>
</div><h2 id="bind-mount">Bind Mount</h2>
<p>使用<code>bind mount</code>时，会将主机上的指定文件或目录挂载到容器上，挂载的方式和volume类似。以<code>--mount</code>标记挂载要加上額外的参数，另外主机上的来源文件(或目录)地址参数必须使用绝对路径。<br>
首先是<code>--mount</code>方式，注意加上<code>type=bind</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d --name nginx nginx:latest <span class="se">\
</span><span class="se"></span>  --mount <span class="nv">type</span><span class="o">=</span>bind,source<span class="o">=</span>/usr/local/target,target<span class="o">=</span>/app
</code></pre></td></tr></table>
</div>
</div><p><code>-v</code>方式范例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d --name nginx nginx:latest <span class="se">\
</span><span class="se"></span>  -v /usr/local/target:/app
</code></pre></td></tr></table>
</div>
</div><h3 id="docker-又是如何做到把一个宿主机上的目录或者文件挂载到容器里面去呢">Docker 又是如何做到把一个宿主机上的目录或者文件，挂载到容器里面去呢</h3>
<p>这里要使用到的挂载技术，就是 Linux 的绑定挂载（bind mount）机制。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。<br>
其实，如果了解 Linux 内核的话，就会明白，绑定挂载实际上是一个 inode 替换的过程。在 Linux 操作系统中，inode 可以理解为存放文件内容的“对象”，而 dentry，也叫目录项，就是访问这个 inode 所使用的“指针”。
<img
        class="lazyload"
        src="/svg/loading/small.min.svg"
        data-src="https://oss.chenjunxin.com/picture/blogPicture/cec51938_bind_mount_principle.webp"
        data-srcset="https://oss.chenjunxin.com/picture/blogPicture/cec51938_bind_mount_principle.webp, https://oss.chenjunxin.com/picture/blogPicture/cec51938_bind_mount_principle.webp 1.5x, https://oss.chenjunxin.com/picture/blogPicture/cec51938_bind_mount_principle.webp 2x"
        data-sizes="auto"
        alt="https://oss.chenjunxin.com/picture/blogPicture/cec51938_bind_mount_principle.webp"
        title="https://oss.chenjunxin.com/picture/blogPicture/cec51938_bind_mount_principle.webp" />
正如上图所示，mount &ndash;bind /home /test，会将 /home 挂载到 /test 上。其实相当于将 /test 的 dentry，重定向到了 /home 的 inode。这样当我们修改 /test 目录时，实际修改的是 /home 目录的 inode。这也就是为何，一旦执行 umount 命令，/test 目录原先的内容就会恢复：因为修改真正发生在的，是 /home 目录里。</p>
<h3 id="-v和--mount不同点"><code>-v</code>和<code>--mount</code>不同点：</h3>
<ul>
<li><code>-v</code>可以主机上不存在的目录。当挂载的路径（目录或文件）不存在，<code>-v</code>会以目录方式建建立该路径，<code>--mount</code>會產生錯誤。</li>
<li>如果<code>bind mount</code>是挂载了主机的一个非空的目录，则容器内的挂载的目录中的原本的内容会被屏蔽掉，以外部主机的目录内容为准。</li>
</ul>
<h3 id="volume与bind-mount不同点"><code>volume</code>与<code>bind mount</code>不同点:</h3>
<ul>
<li><strong>当容器外的对应目录是空的，volume会先将容器内的内容拷贝到容器外目录，而<code>bind mount</code>会将外部的目录覆盖容器内部目录！！</strong></li>
<li><code>volume</code>还有一个不如<code>bind mount</code>的地方，不能直接挂载文件，例如挂载nginx容器的配置文件：nginx.conf。</li>
</ul>
<p>这里需要说明，类似于配置文件这种单文件方式并不适合使用<code>volume</code>，<code>bind mount</code>虽然也可以解决，但由于config文件中包含一些类似于数据库密码等敏感信息，因此，最好的方式是使用<code>tmpfs</code>。</p>
<h2 id="tmpfs-mount">tmpfs mount</h2>
<p><code>tmpfs mount</code>只能用在Linux中运行的Docker，只是暂时性地将资料留在主机内存之中，当容器停止的时候，<code>tmpfs mount</code>就会被移除。它通常用來存放敏感性的资料，另外也不能在多个容器中共用。<br>
要挂载<code>tmpfs mount</code>可以使用<code>--tmpfs</code>或<code>--mount</code>两种标记，和volume的情況类似，在 Docker 17.06 后也可以在容器使用<code>--mount</code>。挂载时不需要指定来源(source)，示范如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d --name tmptest  nginx:latest <span class="se">\
</span><span class="se"></span>  --mount <span class="nv">type</span><span class="o">=</span>tmpfs,destination<span class="o">=</span>/app 
  
$ docker run -d --name tmptest  nginx:latest <span class="se">\
</span><span class="se"></span>  --tmpfs /app 
</code></pre></td></tr></table>
</div>
</div><h2 id="docker数据挂载使用场景总结">Docker数据挂载使用场景总结</h2>
<p>使用 volume 的场景：</p>
<ol>
<li>多个运行容器之间的数据共享。就算停掉容器卷也还存在，多个容器可以同时挂载、读写、只读相同的 volume</li>
<li>当主机不能保证有给定的目录或者文件</li>
<li>存储数据在远程主机或者云上, 而非本地</li>
<li>需要从主机备份、恢复、迁移数据到另一个主机上. 可以停掉容器后，备份卷目录，如 /var/lib/docker/volumes/&lt;volume_name&gt;</li>
</ol>
<p>使用 bind mount 的场景：</p>
<ol>
<li>容器和主机共享配置文件. Docker 默认为容器提供 DNS 解析就是这种方式，从主机挂载 /etc/resolv.conf 到每个容器</li>
<li>和主机的开发环境共享源码或者文件。例如挂载 Maven 的 target 目录到容器，每次 Maven 构建完毕，容器就会访问重构建的文件。</li>
<li>当主机的文件或者目录结构保证与容器所需的<code>bind mount</code>一致</li>
</ol>
<p>使用 tmpfs mount 场景：无需主机和容器间数据的持久存储
tmpfs, 它把数据存储在内存里，不会被写入主机的文件系统或者 docker 内，可以用来存储非持久状态和敏感信息。
<code>docker swarm service</code>就是使用<code>tmpfs</code>挂载<code>docker secrets</code>(如密码、SSH 密钥、SSL 认证等) 到一个服务的容器里。</p>
<p>要注意：</p>
<ul>
<li>当挂载一个空<code>volume</code>到容器的非空目录时，目录里的内容都会被拷贝到卷内。</li>
<li>当挂载一个非空<code>volumne</code>或者<code>bind mount</code>到容器的非空目录时，容器非空目录下的内容都会被遮住。他们没有被删除或者改变，只是无法被访问到了。</li>
<li><code>bind mount</code>和<code>volume</code>都可以使用<code>-v</code>挂载到容器，但是在 Docker 17.06 及更高版本建议使用<code>--mount</code>挂载容器和服务，用于<code>bind mount</code>,<code>volume</code>或者<code>tmpfs mount</code>，这样语法更清晰些。</li>
</ul>
<h2 id="docker-run--v-挂载数据卷异常">docker run -v 挂载数据卷异常</h2>
<p>用docker启动redis的时候出现以下异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d -p 6379:6379  -v <span class="nv">$PWD</span>/data:/data  redis --appendonly yes
d06e8905aeb84458e5930e086f0a087d2ef35774c0cc6a3e1ff9f74b5925a80b
$ docker logs d0
chown: changing ownership of <span class="s1">&#39;./appendonly.aof&#39;</span>: Permission denied
chown: changing ownership of <span class="s1">&#39;.&#39;</span>: Permission denied
</code></pre></td></tr></table>
</div>
</div><p>解决方案，加上–privileged=true</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run -d -p 6379:6379 -v <span class="nv">$PWD</span>/data:/data --privileged<span class="o">=</span><span class="nb">true</span> redis --appendonly yes
</code></pre></td></tr></table>
</div>
</div><p>注:<code>–privileged=true</code>最好紧跟<code> -v</code>指令，要不然可能不起作用。
使用该参数，container内的root拥有真正的root权限,否则，container内的root只是外部的一个普通用户权限。<br>
使用该参数启动的容器，可以看到很多host上的设备，并且可以执行mount,甚至允许你在docker容器中启动docker容器。</p>
<h1 id="docker镜像相关">Docker镜像相关</h1>
<h2 id="docker-hub-镜像加速器">Docker Hub 镜像加速器</h2>
<p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务。</p>
<h3 id="配置加速地址">配置加速地址</h3>
<p>创建或修改 <code>/etc/docker/daemon.json</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
{
    &#34;registry-mirrors&#34;: [
        &#34;https://1nj0zren.mirror.aliyuncs.com&#34;,
        &#34;https://docker.mirrors.ustc.edu.cn&#34;,
        &#34;http://f1361db2.m.daocloud.io&#34;,
        &#34;https://registry.docker-cn.com&#34;
    ]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre></td></tr></table>
</div>
</div><h3 id="docker-hub-镜像加速器列表">Docker Hub 镜像加速器列表</h3>
<table>
<thead>
<tr>
<th>镜像加速器</th>
<th>镜像加速器地址</th>
<th>专属加速器</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="" rel="">Docker 中国官方镜像</a></td>
<td><a href="https://registry.docker-cn.com">https://registry.docker-cn.com</a></td>
<td></td>
</tr>
<tr>
<td><a href="" rel="">DaoCloud 镜像站</a></td>
<td><a href="http://f1361db2.m.daocloud.io">http://f1361db2.m.daocloud.io</a></td>
<td>可登录，系统分配</td>
</tr>
<tr>
<td><a href="" rel="">Azure 中国镜像</a></td>
<td><a href="https://dockerhub.azk8s.cn">https://dockerhub.azk8s.cn</a></td>
<td></td>
</tr>
<tr>
<td><a href="" rel="">科大镜像站</a></td>
<td><a href="https://docker.mirrors.ustc.edu.cn">https://docker.mirrors.ustc.edu.cn</a></td>
<td></td>
</tr>
<tr>
<td><a href="" rel="">阿里云</a></td>
<td>https://&lt;your_code&gt;.mirror.aliyuncs.com</td>
<td>需登录，系统分配</td>
</tr>
<tr>
<td><a href="" rel="">七牛云</a></td>
<td><a href="https://reg-mirror.qiniu.com">https://reg-mirror.qiniu.com</a></td>
<td></td>
</tr>
<tr>
<td><a href="" rel="">网易云</a></td>
<td><a href="https://hub-mirror.c.163.com">https://hub-mirror.c.163.com</a></td>
<td></td>
</tr>
<tr>
<td><a href="" rel="">腾讯云</a></td>
<td><a href="https://mirror.ccs.tencentyun.com">https://mirror.ccs.tencentyun.com</a></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="检查加速器是否生效">检查加速器是否生效</h3>
<p>命令行执行<code>docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Registry Mirrors:
  https://dockerhub.azk8s.cn/
  https://hub-mirror.c.163.com/
  http://f1361db2.m.daocloud.io/
  https://registry.docker-cn.c
</code></pre></td></tr></table>
</div>
</div><h3 id="docker-hub-镜像测速">Docker Hub 镜像测速</h3>
<p>使用镜像前后，可使用<code>time</code>统计所花费的总时间。测速前先移除本地的镜像！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker rmi node:latest
$ <span class="nb">time</span> docker pull node:latest
Pulling repository node
<span class="o">[</span>...<span class="o">]</span>

real   1m14.078s
user   0m0.176s
sys    0m0.120s
</code></pre></td></tr></table>
</div>
</div><h2 id="镜像的导入导出">镜像的导入导出：</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker ps -a</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
e1cfa12a7593        nginx               <span class="s2">&#34;nginx -g &#39;daemon of…&#34;</span>   <span class="m">3</span> minutes ago       Up <span class="m">2</span> minutes        0.0.0.0:32769-&gt;80/tcp   sharp_jepsen
<span class="c1">#将上面镜像名称为nginx的镜像保存到mynginx.tar这个包中</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker save -o mynginx.tar e1cfa12a7593</span>
Error response from daemon: No such image: e1cfa12a7593
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker save -o mynginx.tar nginx</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># ll</span>
-rw-------  <span class="m">1</span> root root  <span class="m">112703488</span> 8月  <span class="m">18</span> 21:19 mynginx.tar
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># ls | grep myngi</span>
mynginx.tar
<span class="o">[</span>root@localhost ~<span class="o">]</span>#
</code></pre></td></tr></table>
</div>
</div><p>发现上面已经有了一个mynginx.tar的包<br>
复制到另一台机器上导入（接下来是机器192.168.106.110机器，上面是109机器）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># pwd</span>
/root
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># ll</span>
-rw-r--r--  <span class="m">1</span> root root <span class="m">112703488</span> 8月  <span class="m">18</span> 21:31 mynginx.tar
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker load &lt; mynginx.tar</span> 
cdb3f9544e4c: Loading layer <span class="o">[==================================================</span>&gt;<span class="o">]</span>  58.44MB/58.44MB
a8c4aeeaa045: Loading layer <span class="o">[==================================================</span>&gt;<span class="o">]</span>  54.24MB/54.24MB
08d25fa0442e: Loading layer <span class="o">[==================================================</span>&gt;<span class="o">]</span>  3.584kB/3.584kB
Loaded image: nginx:latest
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               latest              c82521676580        <span class="m">3</span> weeks ago         109MB
<span class="o">[</span>root@localhost ~<span class="o">]</span>#
</code></pre></td></tr></table>
</div>
</div><p>通过上面我们可以看到开始docker images中没有镜像列表，在导入之后发现多了一个镜像</p>
<h2 id="用commit-提交相关镜像生成一个新镜像">用commit 提交相关镜像生成一个新镜像：</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker ps -a</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                   NAMES
dfd1c30384f1        centos              <span class="s2">&#34;/bin/bash&#34;</span>              About a minute ago   Exited <span class="o">(</span>0<span class="o">)</span> <span class="m">4</span> seconds ago                           ecstatic_booth
e1cfa12a7593        nginx               <span class="s2">&#34;nginx -g &#39;daemon of…&#34;</span>   <span class="m">24</span> minutes ago       Up <span class="m">24</span> minutes              0.0.0.0:32769-&gt;80/tcp   sharp_jepsen
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker commit -m &#34;Add tuzuoquan.txt&#34; -a &#34;toto-txt&#34; dfd1c30384f1 toto</span>
sha256:232eab347b5b848ef4484b47e912515b53b5f75af4d3ae507a0af6e42f10a46d
</code></pre></td></tr></table>
</div>
</div><ul>
<li>-m:表示备注信息</li>
<li>-a:作者相关信息。</li>
<li>dfd1c30384f1：就是刚刚我们创建的容器ID</li>
<li>toto: 表示生成的镜像名称：
当然我们不推荐这种方式，应该使用Dockerfile来操作的。后面才讲。</li>
</ul>
<h3 id="查看本地文件一探究竟">查看本地文件一探究竟：</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># cd /var/lib/docker/</span>
<span class="o">[</span>root@localhost docker<span class="o">]</span><span class="c1"># ll</span>
total <span class="m">8</span>
drwx------. <span class="m">20</span> root root <span class="m">4096</span> Mar <span class="m">12</span> 17:11 containers      <span class="c1">##容器运行相关信息</span>
drwx------.  <span class="m">5</span> root root   <span class="m">50</span> Dec <span class="m">17</span> 22:59 devicemapper    <span class="c1">##存储对应的存储池和相关的元数据</span>
drwx------.  <span class="m">3</span> root root   <span class="m">25</span> Dec <span class="m">17</span> 22:52 image           <span class="c1">##各层相关信息</span>
drwxr-x---.  <span class="m">3</span> root root   <span class="m">18</span> Dec <span class="m">17</span> 22:52 network         
drwx------   <span class="m">4</span> root root   <span class="m">30</span> Feb <span class="m">21</span> 14:26 plugins
drwx------.  <span class="m">2</span> root root    <span class="m">6</span> Dec <span class="m">19</span> 11:54 swarm
drwx------.  <span class="m">5</span> root root   <span class="m">96</span> Mar <span class="m">12</span> 16:57 tmp
drwx------.  <span class="m">2</span> root root    <span class="m">6</span> Dec <span class="m">17</span> 22:52 trust
drwx------. <span class="m">15</span> root root <span class="m">4096</span> Mar  <span class="m">3</span> 00:45 volumes        <span class="c1">##数据卷相关信息</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="docker-login登录非docker-hub仓库">docker login登录非docker hub仓库</h1>
<p>使用语法：docker login [OPTIONS]  [SERVER]，其中options的取值有三种：<code>--password</code>或者<code>-p</code>，表示密码；<code>--password-stdin</code>表示通过标准输入使用密码，这种使用方式输入密码时，不可见；<code>--username</code>或者<code>-u</code>，表示用户名。<br>
一般<code>-u</code>和<code>-p</code>配合使用，默认情况下是通过标准输入来登录，即<code>--password-stdin</code>。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker login -u <span class="nb">test</span> -p <span class="m">123456</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="登录你自己的仓库">登录你自己的仓库</h2>
<p>默认情况下，docker login会登录docker hub上的仓库。如果你想登录其他镜像仓库，你只需要在登录时将服务器名添加进去即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">$docker</span> login registry.csdn.com
</code></pre></td></tr></table>
</div>
</div><p>登录完成后就可以在$HOME/.docker/config.json文件中找到你的相关认证信息，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">{</span>
	<span class="s2">&#34;auths&#34;</span>: <span class="o">{</span>
		<span class="s2">&#34;https://index.docker.io/v1/&#34;</span>: <span class="o">{</span>
			<span class="s2">&#34;auth&#34;</span>: <span class="s2">&#34;aJKvamllasdffzp6aGoxJKL2RTY=&#34;</span>
		<span class="o">}</span>,
		<span class="s2">&#34;registry.csdn.com&#34;</span>: <span class="o">{</span>
			<span class="s2">&#34;auth&#34;</span>: <span class="s2">&#34;aJKvamllasdffW86WmhqBNMyMzE2&#34;</span>
		<span class="o">}</span>
	<span class="o">}</span>,
	<span class="s2">&#34;HttpHeaders&#34;</span>: <span class="o">{</span>
		<span class="s2">&#34;User-Agent&#34;</span>: <span class="s2">&#34;Docker-Client/18.06.1-ce (linux)&#34;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="退出仓库">退出仓库</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">$docker</span> <span class="nb">logout</span> registry.csdn.com
</code></pre></td></tr></table>
</div>
</div><h1 id="使用dockerfile-创建镜像遇到的坑">使用Dockerfile 创建镜像遇到的坑</h1>
<p>当用Dockerfile去创建容器，步骤如下：</p>
<h2 id="创建并编辑dockerfile">创建并编辑dockerfile</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">mkdir mydocker
<span class="nb">cd</span> /mydocker
vim DockerFile
<span class="o">(</span>输入以下指令<span class="o">)</span>
  FROM centos（指定其后构建新镜像所使用的基础镜像）
  VOLUME <span class="o">[</span><span class="s2">&#34;/opt/dockerShare1&#34;</span>,<span class="s2">&#34;/opt/dockerShare2&#34;</span><span class="o">]</span>（容器中的挂载点）
  CMD <span class="nb">echo</span> <span class="s2">&#34;finish scuess !!!!&#34;</span>（指定在容器启动时所要执行的命令）
  CMD /bin/bash
</code></pre></td></tr></table>
</div>
</div><p>保存退出</p>
<h2 id="使用build命令">使用build命令</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker build -f /mydocker/Dockfile -t mycentos:1.01
<span class="c1"># --tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span>
<span class="c1"># -f :指定要使用的Dockerfile路径；</span>
</code></pre></td></tr></table>
</div>
</div><p>但是这里却报错了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="s2">&#34;docker build&#34;</span> requires exactly <span class="m">1</span> argument<span class="o">(</span>s<span class="o">)</span>.
</code></pre></td></tr></table>
</div>
</div><p>后面在官网看到这行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker build -f dockerfiles/Dockerfile.debug -t myapp_debug .

$ docker build -f dockerfiles/Dockerfile.prod -t myapp_prod .
</code></pre></td></tr></table>
</div>
</div><p>大致意思是说：
此示例指定路径为<code>.</code>因此，本地目录中的所有文件都被排序并发送到Docker守护进程。该路径指定在何处找到Docker守护进程上构建的“上下文”的文件。
所以，要想用指定路径的Dockerfile构建，貌似必须用这个<code> .</code> 。</p>
<h1 id="docker-容器日志">Docker 容器日志</h1>
<h2 id="docker-logs命令概述">docker logs命令概述</h2>
<p><code>docker logs</code>: 获取容器的日志<br>
语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker logs [OPTIONS] CONTAINER
</code></pre></td></tr></table>
</div>
</div><p>OPTIONS说明：</p>
<ul>
<li>-f : 跟踪日志输出</li>
<li>&ndash;since :显示某个开始时间的所有日志</li>
<li>-t : 显示时间戳</li>
<li>&ndash;tail :仅列出最新N条容器日志</li>
</ul>
<h2 id="docker-logs实例">docker logs实例</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1">#跟踪查看容器mynginx的日志输出。</span>
$ docker logs -f mynginx

<span class="c1">#查看容器mynginx从2016年7月1日后的最新10条日志。</span>
docker logs --since<span class="o">=</span><span class="s2">&#34;2016-07-01&#34;</span> --tail<span class="o">=</span><span class="m">10</span> mynginx
</code></pre></td></tr></table>
</div>
</div><h1 id="docker-下的网络模式">Docker 下的网络模式</h1>
<p>构建容器的时候使用了<code>--net anyesu_net</code>这个选项, 意思是让容器使用自定义的网络 anyesu_net , <strong>注意：Docker默认是根据容器运行的顺序设置IP的，所以会出现重启容器后IP改变的情况</strong>，以下是对Docker 下四种网络模式的一个简单介绍。</p>
<h2 id="bridge">bridge</h2>
<p>这是 Docker 默认使用的模式, Docker Daemon 启动时默认会创建 Docker0 这个网桥, 网段为 172.17.0.0/16 , 宿主机 IP 为 172.17.0.1 , 作为这个虚拟子网的 网关 。</p>
<p>当然, 也可以新建一个名为 anyesu_net 网段为 172.18.0.0/16 的网桥：</p>
<p>docker network create &ndash;subnet=172.18.0.0/16 anyesu_net
启动 容器 时指定 &ndash;net anyesu_net 即可。</p>
<h2 id="host">host</h2>
<p>容器 共享 宿主机 的网络 ( IP 和 端口 ) 。使用 Docker 有相当一部分目的是为了隔离 宿主机 和 容器 , 使用 host 模式就违背了这一点, 不是很好。另外有很多 镜像 如 tomcat 默认监听 8080 端口的, 使用 host 模式后开多个 容器 就会造成端口冲突, 而不得不修改 tomcat 的监听端口。</p>
<h2 id="none">none</h2>
<p>这种模式下, 创建的 容器 拥有自己的 Network Namespace, 但是没有任何网络配置, 所以默认是没有网络的, 可以自己对 容器 的 网卡、IP 进行配置, 适合用来配置比默认设置更加复杂的网络环境。</p>
<h2 id="container">container</h2>
<p>类似于 host 模式, 不过这种模式是共享已存在的 容器 使用的网络。</p>
<h1 id="获取-docker-容器container的-ip-地址">获取 docker 容器(container)的 ip 地址</h1>
<ol>
<li>进入容器内部后</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1">#显示自己以及(– link)软连接的容器IP</span>
$ cat /etc/hosts
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>使用命令</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker inspect --format <span class="s1">&#39;{{ .NetworkSettings.IPAddress }}&#39;</span> &lt;container-ID&gt;
或
$ docker inspect &lt;container id&gt;
或
$ docker inspect -f <span class="s1">&#39;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39;</span> container_name_or_id
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>可以考虑在 ~/.bashrc 中写一个 bash 函数：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="k">function</span> docker_ip<span class="o">()</span> <span class="o">{</span>
    sudo docker inspect --format <span class="s1">&#39;{{ .NetworkSettings.IPAddress }}&#39;</span> <span class="nv">$1</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>source ~/.bashrc</code> 然后：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker_ip &lt;container-ID&gt;
172.17.0.6
</code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>要获取所有容器名称及其IP地址只需一个命令。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker inspect -f <span class="s1">&#39;{{.Name}} - {{.NetworkSettings.IPAddress }}&#39;</span> <span class="k">$(</span>docker ps -aq<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果使用docker-compose命令将是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker inspect -f <span class="s1">&#39;{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39;</span> <span class="k">$(</span>docker ps -aq<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>显示所有容器IP地址：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker inspect --format<span class="o">=</span><span class="s1">&#39;{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39;</span> <span class="k">$(</span>docker ps -aq<span class="k">)</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="一些docker命令">一些Docker命令</h1>
<h2 id="运行相关">运行相关</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># -t 终端</span>
<span class="c1"># -i 交互操作</span>
docker run -it ubuntu /bin/bash

<span class="c1"># 后台运行一个容器</span>
docker run -d -it ubuntu
</code></pre></td></tr></table>
</div>
</div><p>附着到正在运行的容器, 附着完以后退出会导致容器也终止</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker attach 容器id
</code></pre></td></tr></table>
</div>
</div><p>进入正在运行的 container 并且执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker <span class="nb">exec</span> -it 839a6cfc9496 /bin/bash

<span class="c1">#注意这里如果后面用exit命令退出容器，会导致容器也停止。正确的退出方式是按住Ctrl键+大写P+大写Q</span>
</code></pre></td></tr></table>
</div>
</div><p>在容器中运行一段程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run ubuntu apt-get update
</code></pre></td></tr></table>
</div>
</div><p>拷贝文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1">#将容器中文件拷往主机</span>
$ docker cp  CONTAINER_ID:SRC_PATH DEST_PATH

<span class="c1">#eg：将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中</span>
$ docker cp  96f7f14e99ab:/www /tmp/

<span class="c1">#eg:将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www</span>
$ docker cp /www/runoob 96f7f14e99ab:/www

<span class="c1"># 从主机往容器中拷贝</span>
$ docker cp SRC_PATH CONTAINER_ID:DEST_PATH

<span class="c1"># eg：将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下</span>
$ docker cp /www/runoob 96f7f14e99ab:/www/
</code></pre></td></tr></table>
</div>
</div><h1 id="参考链接">参考链接</h1>
<ul>
<li><a href="https://www.jianshu.com/p/082bf977ce0e" target="_blank" rel="noopener noreffer">Docker 常见问题汇总(转)</a></li>
<li><a href="https://www.cnblogs.com/Survivalist/p/11199292.html" target="_blank" rel="noopener noreffer">一篇文章学会Docker命令</a></li>
<li><a href="https://juejin.im/post/5d58db96e51d453bc64801d5" target="_blank" rel="noopener noreffer">Docker入门-数据挂载</a></li>
<li><a href="https://blog.csdn.net/qingyafan/article/details/89577717" target="_blank" rel="noopener noreffer">Docker - 挂载目录（bind mounts）和Volume是不同的</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10207973" target="_blank" rel="noopener noreffer">[Day 21] Docker (7)</a></li>
<li><a href="https://rjerk.xyz/index.php/archives/73/" target="_blank" rel="noopener noreffer">Docker: volume 使用</a></li>
<li><a href="https://blog.liu-kevin.com/2019/06/02/dockergua-zai/" target="_blank" rel="noopener noreffer">5. docker之挂载</a></li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>本文于 2020-04-25 更新</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" data-title="Docker踩坑后的总结" data-hashtags="Docker"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" data-hashtag="Docker"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" data-title="Docker踩坑后的总结" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" data-title="Docker踩坑后的总结"><i class="fab fa-line fa-fw"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" data-title="Docker踩坑后的总结"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" data-title="Docker踩坑后的总结" data-description="在封装Docker镜像还有启动容器的时候，被Docker在挂载目录方面的内容坑了下，后面处理完也加深了对Docker的一些了解，在这里总结一下。"><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></i></a><a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" data-title="Docker踩坑后的总结" data-description="在封装Docker镜像还有启动容器的时候，被Docker在挂载目录方面的内容坑了下，后面处理完也加深了对Docker的一些了解，在这里总结一下。"><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://chenjunxin.com/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/" data-title="Docker踩坑后的总结"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/docker/">Docker</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/" class="prev" rel="prev" title="Nginx上部署TLS1.3和Brotli"><i class="fas fa-angle-left fa-fw"></i>Nginx上部署TLS1.3和Brotli</a>
            <a href="/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="next" rel="next" title="Base64编码的了解与使用">Base64编码的了解与使用<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.69.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.5"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2017 - 2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">JohnnyChan</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp">粤ICP备17106857号-2</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript">
    window.config = {"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"headerMode":{"desktop":"fixed","mobile":"auto"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};
</script><script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=html5shiv%2CElement.prototype.closest%2CrequestAnimationFrame%2CCustomEvent%2CPromise%2CObject.entries%2CObject.assign%2CObject.values%2Cfetch%2CElement.prototype.after%2CArray.prototype.fill%2CIntersectionObserver%2CArray.from%2CArray.prototype.find%2CMath.sign"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/object-fit-images/ofi.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
