[{"categories":["编码","Base64编码"],"content":"Base64 是一种使用 64 个可打印的字符来表示二进制数据的方法，Base64 中仅且包括字母 A-Za-z0-9+/ 共64个字符。Base64通常处理文本数据，表示、传输、存储二进制数据。","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"Base64是什么  Base64是一种常用的简单的编解码方式，有些网络传送渠道不支持所有字节，比如邮件发送，图像字节不可能全部都是可见字符，所以受到了很大限制。最好的解决办法就是在不改变传统协议的情况下，利用一种扩展方式来支持二进制文件的传送，把不可打印的字符用可打印字符来表示。Base64 就是一种基于64个可打印字符来表示二进制数据的方法。 电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。 Base64不是一种加密方式，因此它不提供任何安全特性。在论坛、个人博客中发现很多人使用 Base64编码显示自己邮箱主要是避免被搜索引擎及其他批量化工具发现和索引。 Base64原理 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:0:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"btoa 和 atob 的意义  首先我们要知道为什么编码叫 btoa，而解码叫 atob btoa = binary to ASCII = encode atob = ASCII to binary = decode C语言中有一个函数叫 atoi，意思是 convert a string to an integer，也就是 “10” =\u003e 10 i 是 integer 很好理解，那为什么 a 是 string 呢？ a 其实是 ASCII 的缩写，ASCII 也是一种编码，string 为什么还有编码呢？因为电脑只认识二进制0和1，string 和 二进制的对应关系就是编码，比如 01100001 对应字符 ‘a’ 就是由 ASCII 编码规定的。 理解了 atoi 再理解 btoa 就很简单了，a 是 ASCII，也就是 string，而 b 就是 binary。 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"原理  理解Base64或其他类似编码的关键有两点： 计算机最终存储和执行的是01二进制序列，这个二进制序列的含义则由解码程序/解释程序决定 很多场景下的数据传输要求数据只能由简单通用的字符组成，比如HTTP协议要求请求的首行和请求头都必须是ASCII编码  Base64的原理比较简单，每当我们使用Base64时都会先定义一个类似这样的数组：[‘A’, ‘B’, ‘C’, … ‘a’, ‘b’, ‘c’, … ‘0’, ‘1’, … ‘+’, ‘/']。 上面就是Base64的索引表，字符选用了A-Z、a-z、0-9、+、/ 64个可打印字符，这是标准的Base64协议规定。在日常使用中我们还会看到=或==号出现在Base64的编码结果中，=在此是作为填充字符出现。 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"具体转换步骤 将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。 将上面的24个二进制位每6个一组，共分为4组。 在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。 根据Base64编码对照表（见下表）获得对应的值。 Table 1: The Base 64 Alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w (pad) = 15 P 32 g 49 x 16 Q 33 h 50 y 从上面的步骤我们发现： Base64字符表中的字符原本用6个bit就可以表示，现在前面添加2个0，变为8个bit，会造成一定的浪费。因此，Base64编码之后的文本，要比原文大约三分之一。 为什么使用3个字节一组呢？因为6和8的最小公倍数为24，三个字节正好24个二进制位，每6个bit位一组，恰好能够分为4组。 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"示例说明 原始字符 T o m ASCII十进制值 84 111 109 二进制值(8bit1字节): 01010100 01101111 01101101 Base64编码二进制值(6bit1字节): 010101 000110 111101 101101 Base64编码十进制值: 21 6 61 45 Base64编码后的字符: V G 9 t 因此 Tom 在 Base64 编码之后变成了 VG9t。 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"位数不足情况 上面是按照三个字节来举例说明的，如果字节数不足三个，那么该如何处理？ 原始字符 A ASCII十进制值 65 二进制值(8bit1字节): 01000001 Base64编码二进制值(6bit1字节)，后面补0: 010000 010000 Base64编码十进制值: 16 16 Base64编码后的字符: Q Q = = 原始字符 B C ASCII十进制值 66 67 二进制值(8bit1字节): 01000010 01000011 Base64编码二进制值(6bit1字节)，后面补0: 010000 100100 001100 Base64编码十进制值: 16 36 12 Base64编码后的字符: Q k M = 两个字节：两个字节共16个二进制位，依旧按照规则进行分组。此时总共16个二进制位，每6个一组，则第三组缺少2位，用0补齐，得到三个Base64编码，第四组完全没有数据则用“=”补上。因此，上图中“BC”转换之后为“QKM=”； 一个字节：一个字节共8个二进制位，依旧按照规则进行分组。此时共8个二进制位，每6个一组，则第二组缺少4位，用0补齐，得到两个Base64编码，而后面两组没有对应数据，都用“=”补上。因此，上图中“A”转换之后为“QQ==”； ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:1","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"注意事项 大多数编码都是由字符串转化成二进制的过程，而Base64的编码与常规恰恰相反,是从二进制转换为字符串。 Base64编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱Base64编码来进行加密，但是还是容易被破解。 中文有多种编码（比如：utf-8、gb2312、gbk等），不同编码对应Base64编码结果都不一样。 上面我们已经看到了Base64就是用6位（2的6次幂就是64）表示字符，因此成为Base64。同理，Base32就是用5位，Base16就是用4位。 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"验证 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:6:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"Linux命令  较高版本的Linux提供了命令行方式的Base64编码和解码。 **注意：**echo默认是有换行的， -n的时候， 是不换行的。不加-n的话 会导致出来的结果是不一样的，我试过，后面用Java8的Base64工具解密得出来，发现比起用Java8的直接加密，结果多了一个换行符”\\n”。 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:6:1","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"Java8验证 public static void main(String[] args) { System.out.println(System.getProperty(\"file.encoding\")); final Base64.Decoder decoder = Base64.getDecoder(); final Base64.Encoder encoder = Base64.getEncoder(); String[] testText = {\"A\", \"B\"}; for (String s : testText) { byte[] textByte = s.getBytes(StandardCharsets.UTF_8); //编码 String encodedText = encoder.encodeToString(textByte); System.out.println(encodedText); //解码 System.out.println(new String(decoder.decode(encodedText), StandardCharsets.UTF_8)); } } 结果如下图: Base64 的字典表  Base64 根据编码字典表不同以及是否 padding (使用=作为 padding 字符)，对同一数据的编码结果可能不同。使用最多的字典表有两个：标准的字典表与URL Safe版本字典表(如下)。 Table 2: The \"URL and Filename safe\" Base 64 Alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 - (minus) 12 M 29 d 46 u 63 _ 13 N 30 e 47 v (underline) 14 O 31 f 48 w 15 P 32 g 49 x 16 Q 33 h 50 y (pad) =  标准 Base64 中的两个非字母数字 + 和 / 设计的特别坑爹，因为它们不管在 url 中还有文件系统中都属于特殊字符。 而剩下的那个 padding 字符 = 就更坑爹了，因为 = 直接就是 query string 中的 equal 字符。 因此机智的人类又发明了 Base64 url safe 版本，和标准版区别有三： + 被 - 代替，加号对应减号 / 被 _ 代替 没有 = 这个 padding 字符 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:6:2","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"Base64 编码结果中的等号（=）可以省略吗？是多余的设计吗？  可以省略，但不是多余的设计。 对于数据 A, 如果我们省略padding的等号，解码的时候我们从QQ是可以推断出来，原始数据长度必然是1 byte, 因此可以可以正确解码。数据 BC 同理。 但是对于一些将多个Base64编码拼接在一起的场景，padding的等号可以标记一个 Base64 编码单元的边界，使得拼接后的 Base64 编码整体是可以无歧义正确解码的。如果省略等号，则无法保证无歧义性。我们看一个例子： I Base64编码为 SQ (SQ== with padding) AM Base64编码为 QU0 (QU0= with padding) Daniel Base64编码为 RGFuaWVs (RGFuaWVs with padding)  如果使用省略等号的方式，拼接后的Base64编码是 SQQU0RGFuaWVs, 因为我们无法区分边界，我们只能对整个字符串进行解码，显然解码结果是不正确的。如果不省略等号，则拼接后的编码 SQ==QU0=RGFuaWVs 可以根据等号区分边界，然后分块正确解码。 Base64用途 Base64 大部分用处是用在二进制文件上的，任何数据都能被 Base64，因为 Base64 接受的参数是 binary，任何数据都是 binary，如 img, mp3, gzip 等。 Base64 最大的好处是二进制文件本来是完全不可读而且不可显示的，转成 Base64 就成了文本，不仅可读可编辑，而且传输数据也方便。 Base64是可逆的，在只可以传递纯文本的时候，通过 Base64 我们就可以传递一切了 不过正因为如此，Base64 肯定是不能用来加密的，因此 Base64 的 encode 和 decode 应该称为编码和解码，而不能称为加密和解密 然不能用来加密，但可以用来混淆，比如邮箱地址。 MarkDown中也能用利用Base64编码插入图片 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:7:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"切忌误用  有人在不理解Base64编码的情况下，将其误用于数据加密或数据校验。 Base64是一种数据编码方式，目的是让数据符合传输协议的要求。标准Base64编码解码无需额外信息即完全可逆，即使你自己自定义字符集设计一种类Base64的编码方式用于数据加密，在多数场景下也较容易破解。 对于数据加密应该使用专门的目前还没有有效方式快速破解的加密算法。比如：对称加密算法AES-128-CBC，对称加密需要密钥，只要密钥没有泄露，通常难以破解；也可以使用非对称加密算法，如 RSA，使得使用公钥加密的数据，只有使用私钥才能快速解密。 对于数据校验，也应该使用专门的消息认证码生成算法，如HMAC， 一种使用单向散列函数构造消息认证码的方法，其过程是不可逆的、唯一确定的，并且使用密钥来生成认证码，其目的是防止数据在传输过程中被篡改或伪造。将原始数据与认证码一起传输，数据接收端将原始数据使用相同密钥和相同算法再次生成认证码，与原有认证码进行比对，校验数据的合法性。  那么针对各大网站被脱库的问题，请问应该怎么存储用户的登录密码？ 答案是：在注册时，根据用户设置的登录密码，生成其消息认证码，然后存储用户名和消息认证码，不存储原始密码。每次用户登录时，根据登录密码，生成消息认证码，与数据库中存储的消息认证码进行比对，以确认是否为有效用户，这样即使网站被脱库，用户的原始密码也不会泄露，不会为用户使用的其他网站带来账号风险。 当然，使用的消息认证码算法其哈希碰撞的概率应该极低才行，目前一般在HMAC算法中使用SHA256。对于这种方式需要注意一点：防止用户使用弱密码，否则也可能会被暴力破解。现在的网站一般要求用户密码6个字符以上，并且同时有数字和大小写字母，甚至要求有特殊字符。另外，也可以使用加入随机salt的哈希算法来存储校验用户密码。 Base64工具与实现 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:8:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"Linux命令：base64 base64 命令用于对文件或者标准输入进行编码和解码。 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:9:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"用法 $ base64 --help 用法：base64 [选项]... [文件] 使用 Base64 编码/解码文件或标准输入输出。 如果没有指定文件，或者文件为\"-\"，则从标准输入读取。 必选参数对长短选项同时适用。 -d, --decode 解码数据 -i, --ignore-garbag 解码时忽略非字母字符 -w, --wrap=字符数 在指定的字符数后自动换行(默认为76)，0 为禁用自动换行 --help 显示此帮助信息并退出 --version 显示版本信息并退出 数据以 RFC 4648 规定的 base64 字母格式进行编码。 解码时，输入数据（编码流）可能包含一些非有效 base64 字符的换行符。 可以尝试用 --ignore-garbage 选项来绕过编码流中的无效字符。 GNU coreutils 在线帮助：\u003chttps://www.gnu.org/software/coreutils/\u003e 请向 \u003chttp://translationproject.org/team/zh_CN.html\u003e 报告 base64 的翻译错误 完整文档请见：\u003chttps://www.gnu.org/software/coreutils/base64\u003e 或者在本地使用：info '(coreutils) base64 invocation' ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:9:1","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"示例 编码标准输入 # 在终端输入 `base64` ，执行后，在终端中输入要编码的内容，按 `ctrl+D` 结束输入 $ base64 你好 5L2g5aW9Cg== #echo命令默认带换行符 $ echo \"你好\" | base64 5L2g5aW9Cg== #echo -n不带换行符 $ echo -n \"你好\" | base64 5L2g5aW9 编码文件 $ touch testing.txt $ echo \"你好\"\u003e testing.txt $ base64 testing.txt 5L2g5aW9Cg== 解码标准输入 $ base64 -d 5L2g5aW9Cg== 你好 解码文件 $ base64 testing.txt \u003e encoded.txt $ cat encoded.txt 5L2g5aW9Cg== $ base64 -d encoded.txt \u003e decoded.txt $ cat decoded.txt 你好 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:9:2","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编码","Base64编码"],"content":"Java使用 参考文章关于base64编码Encode和Decode编码的几种方式与Java Base64 加密与解密,推荐是用Java8自带的Base64工具类。 扩展 Base64还能进行数据隐写,可以看这两篇文章：神奇的 Base64 隐写和base64数据隐写实现原理分析 参考链接 魔鬼在细节中：Base64 你可能不知道的几个细节 base64 前世今生 关于base64编码Encode和Decode编码的几种方式 每天学习一个命令: base64 编解码 Base64编码原理与应用 ","date":"2020-04-27","objectID":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/:10:0","tags":["Base64编码"],"title":"Base64编码的了解与使用","uri":"/base64%E7%BC%96%E7%A0%81%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["技术","Docker"],"content":"在封装Docker镜像还有启动容器的时候，被Docker在挂载目录方面的内容坑了下，后面处理完也加深了对Docker的一些了解，在这里总结一下。","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"Docker数据挂载 要想将容器的内容保存在主机上，Docker有两种做法：volumn和bind mount,在Linux系统上的Docker还可以使用tmpfs mount。三种方式的差异如下图所示: volume 存放在主机中由 Docker 管理的地方，在 Linux 系统上是在 /var/lib/docker/volumes/ 路径下。非 Docker 的程序不应该修改此路径下的文件。要保存Docker中的文件资料 ，volumes 是最好的方法。 bind mount 可存放在主机的任意位置的文件夹上，无论是否是 Docker 容器都可以随时修改其中的内容。 tmpfs mount 只存放在内存中，不会写入系统的文件系统，即硬盘上。 以下是对三种方式的进一步说明： ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:0:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"Volume volume(数据卷)是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： volume可以在容器之间共享和重用 对volume的修改会立马生效 对volume的更新，不会影响镜像 volume默认会一直存在，即使容器被删除 注意：volume的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的volume。 volume(数据卷)是由 Docker 建立与管理的，可用docker volume create指令直接建立，或者在建立容器或服务时一起建立。volume创建时存放在主机的目录中，将volume挂载到容器中，就是挂载该目录。一个 volume 可同時挂载到多个容器中，即使沒有运行中的容器使用此volume，它对 Docker 还是可用的，不会被自动删除。volume可以是具名或匿名 (anonymous) 的，Docker 会给匿名volume生成一个随机的目录名，然后在该目录名下的_data文件夹下，在同一个 Docker 主机中不会有重复。 与 volume 相关的命令為docker volume 创建一个volume $ docker volume create my-vol create 之后如果不加参数，就会建立一个匿名volume，由 Docker给此 volume一個随机的名字。 列出volume $ docker volume ls DRIVER VOLUME NAME local fce415e10e9142e304769ff2f4cd1d45faf9fba17aaa309e4bcd7a3e53eaaaae local my-vol 前者是匿名volume，后者是具体名字的volume 查看指定volume信息 $ docker volume inspect my-vol [ { \"CreatedAt\": \"2020-04-27T09:32:52+08:00\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\", \"Name\": \"my-vol\", \"Options\": {}, \"Scope\": \"local\" } ] 启动一个挂载volume的容器 在用docker run命令的时候，使用-v或者--mount标记来将volume 挂载到容器里。在一次 docker run 中可以挂载多个volume。 下面创建一个名为web的容器，并加载一个volume到容器的 /webapp 目录。 $ docker run -d -P \\ --name web training/webapp:latest \\ -v my-vol:/wepapp #--mount source=my-vol,target=/webapp 查看volume的具体信息 使用以下命令可以查看web容器的数据卷信息： $ docker inspect web volume信息在 “Mounts” Key 下面 \"Mounts\": [ { \"Type\": \"volume\", \"Name\": \"my-vol\", \"Source\": \"/var/lib/docker/volumes/my-vol/_data\", \"Destination\": \"/app\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" } ], 移除volume $ docker volume rm my-vol 数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。 如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用命令 $ docker rm -v 容器id 无主的数据卷可能会占据很多空间，要清理请使用以下命令 $ docker volume prune ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:1:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"Bind Mount 使用bind mount时，会将主机上的指定文件或目录挂载到容器上，挂载的方式和volume类似。以--mount标记挂载要加上額外的参数，另外主机上的来源文件(或目录)地址参数必须使用绝对路径。 首先是--mount方式，注意加上type=bind。 $ docker run -d --name nginx nginx:latest \\ --mount type=bind,source=/usr/local/target,target=/app -v方式范例： $ docker run -d --name nginx nginx:latest \\ -v /usr/local/target:/app ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:2:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"Docker 又是如何做到把一个宿主机上的目录或者文件，挂载到容器里面去呢 这里要使用到的挂载技术，就是 Linux 的绑定挂载（bind mount）机制。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。 其实，如果了解 Linux 内核的话，就会明白，绑定挂载实际上是一个 inode 替换的过程。在 Linux 操作系统中，inode 可以理解为存放文件内容的“对象”，而 dentry，也叫目录项，就是访问这个 inode 所使用的“指针”。 正如上图所示，mount –bind /home /test，会将 /home 挂载到 /test 上。其实相当于将 /test 的 dentry，重定向到了 /home 的 inode。这样当我们修改 /test 目录时，实际修改的是 /home 目录的 inode。这也就是为何，一旦执行 umount 命令，/test 目录原先的内容就会恢复：因为修改真正发生在的，是 /home 目录里。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:2:1","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"-v和--mount不同点： -v可以主机上不存在的目录。当挂载的路径（目录或文件）不存在，-v会以目录方式建建立该路径，--mount會產生錯誤。 如果bind mount是挂载了主机的一个非空的目录，则容器内的挂载的目录中的原本的内容会被屏蔽掉，以外部主机的目录内容为准。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:2:2","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"volume与bind mount不同点: 当容器外的对应目录是空的，volume会先将容器内的内容拷贝到容器外目录，而bind mount会将外部的目录覆盖容器内部目录！！ volume还有一个不如bind mount的地方，不能直接挂载文件，例如挂载nginx容器的配置文件：nginx.conf。 这里需要说明，类似于配置文件这种单文件方式并不适合使用volume，bind mount虽然也可以解决，但由于config文件中包含一些类似于数据库密码等敏感信息，因此，最好的方式是使用tmpfs。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:2:3","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"tmpfs mount tmpfs mount只能用在Linux中运行的Docker，只是暂时性地将资料留在主机内存之中，当容器停止的时候，tmpfs mount就会被移除。它通常用來存放敏感性的资料，另外也不能在多个容器中共用。 要挂载tmpfs mount可以使用--tmpfs或--mount两种标记，和volume的情況类似，在 Docker 17.06 后也可以在容器使用--mount。挂载时不需要指定来源(source)，示范如下： $ docker run -d --name tmptest nginx:latest \\ --mount type=tmpfs,destination=/app $ docker run -d --name tmptest nginx:latest \\ --tmpfs /app ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:3:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"Docker数据挂载使用场景总结 使用 volume 的场景： 多个运行容器之间的数据共享。就算停掉容器卷也还存在，多个容器可以同时挂载、读写、只读相同的 volume 当主机不能保证有给定的目录或者文件 存储数据在远程主机或者云上, 而非本地 需要从主机备份、恢复、迁移数据到另一个主机上. 可以停掉容器后，备份卷目录，如 /var/lib/docker/volumes/\u003cvolume_name\u003e 使用 bind mount 的场景： 容器和主机共享配置文件. Docker 默认为容器提供 DNS 解析就是这种方式，从主机挂载 /etc/resolv.conf 到每个容器 和主机的开发环境共享源码或者文件。例如挂载 Maven 的 target 目录到容器，每次 Maven 构建完毕，容器就会访问重构建的文件。 当主机的文件或者目录结构保证与容器所需的bind mount一致 使用 tmpfs mount 场景：无需主机和容器间数据的持久存储 tmpfs, 它把数据存储在内存里，不会被写入主机的文件系统或者 docker 内，可以用来存储非持久状态和敏感信息。 docker swarm service就是使用tmpfs挂载docker secrets(如密码、SSH 密钥、SSL 认证等) 到一个服务的容器里。 要注意： 当挂载一个空volume到容器的非空目录时，目录里的内容都会被拷贝到卷内。 当挂载一个非空volumne或者bind mount到容器的非空目录时，容器非空目录下的内容都会被遮住。他们没有被删除或者改变，只是无法被访问到了。 bind mount和volume都可以使用-v挂载到容器，但是在 Docker 17.06 及更高版本建议使用--mount挂载容器和服务，用于bind mount,volume或者tmpfs mount，这样语法更清晰些。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:4:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"docker run -v 挂载数据卷异常 用docker启动redis的时候出现以下异常： $ docker run -d -p 6379:6379 -v $PWD/data:/data redis --appendonly yes d06e8905aeb84458e5930e086f0a087d2ef35774c0cc6a3e1ff9f74b5925a80b $ docker logs d0 chown: changing ownership of './appendonly.aof': Permission denied chown: changing ownership of '.': Permission denied 解决方案，加上–privileged=true $ docker run -d -p 6379:6379 -v $PWD/data:/data --privileged=true redis --appendonly yes 注:–privileged=true最好紧跟 -v指令，要不然可能不起作用。 使用该参数，container内的root拥有真正的root权限,否则，container内的root只是外部的一个普通用户权限。 使用该参数启动的容器，可以看到很多host上的设备，并且可以执行mount,甚至允许你在docker容器中启动docker容器。 Docker镜像相关 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:5:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"Docker Hub 镜像加速器 国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:6:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"配置加速地址 创建或修改 /etc/docker/daemon.json： sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [ \"https://1nj0zren.mirror.aliyuncs.com\", \"https://docker.mirrors.ustc.edu.cn\", \"http://f1361db2.m.daocloud.io\", \"https://registry.docker-cn.com\" ] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:6:1","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"Docker Hub 镜像加速器列表 镜像加速器 镜像加速器地址 专属加速器 Docker 中国官方镜像 https://registry.docker-cn.com DaoCloud 镜像站 http://f1361db2.m.daocloud.io 可登录，系统分配 Azure 中国镜像 https://dockerhub.azk8s.cn 科大镜像站 https://docker.mirrors.ustc.edu.cn 阿里云 https://\u003cyour_code\u003e.mirror.aliyuncs.com 需登录，系统分配 七牛云 https://reg-mirror.qiniu.com 网易云 https://hub-mirror.c.163.com 腾讯云 https://mirror.ccs.tencentyun.com ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:6:2","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"检查加速器是否生效 命令行执行docker info，如果从结果中看到了如下内容，说明配置成功。 Registry Mirrors: https://dockerhub.azk8s.cn/ https://hub-mirror.c.163.com/ http://f1361db2.m.daocloud.io/ https://registry.docker-cn.c ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:6:3","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"Docker Hub 镜像测速 使用镜像前后，可使用time统计所花费的总时间。测速前先移除本地的镜像！ $ docker rmi node:latest $ time docker pull node:latest Pulling repository node [...] real 1m14.078s user 0m0.176s sys 0m0.120s ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:6:4","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"镜像的导入导出： [root@localhost ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e1cfa12a7593 nginx \"nginx -g 'daemon of…\" 3 minutes ago Up 2 minutes 0.0.0.0:32769-\u003e80/tcp sharp_jepsen #将上面镜像名称为nginx的镜像保存到mynginx.tar这个包中 [root@localhost ~]# docker save -o mynginx.tar e1cfa12a7593 Error response from daemon: No such image: e1cfa12a7593 [root@localhost ~]# docker save -o mynginx.tar nginx [root@localhost ~]# ll -rw------- 1 root root 112703488 8月 18 21:19 mynginx.tar [root@localhost ~]# ls | grep myngi mynginx.tar [root@localhost ~]# 发现上面已经有了一个mynginx.tar的包 复制到另一台机器上导入（接下来是机器192.168.106.110机器，上面是109机器）： [root@localhost ~]# pwd /root [root@localhost ~]# ll -rw-r--r-- 1 root root 112703488 8月 18 21:31 mynginx.tar [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE [root@localhost ~]# docker load \u003c mynginx.tar cdb3f9544e4c: Loading layer [==================================================\u003e] 58.44MB/58.44MB a8c4aeeaa045: Loading layer [==================================================\u003e] 54.24MB/54.24MB 08d25fa0442e: Loading layer [==================================================\u003e] 3.584kB/3.584kB Loaded image: nginx:latest [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest c82521676580 3 weeks ago 109MB [root@localhost ~]# 通过上面我们可以看到开始docker images中没有镜像列表，在导入之后发现多了一个镜像 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:7:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"用commit 提交相关镜像生成一个新镜像： [root@localhost ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES dfd1c30384f1 centos \"/bin/bash\" About a minute ago Exited (0) 4 seconds ago ecstatic_booth e1cfa12a7593 nginx \"nginx -g 'daemon of…\" 24 minutes ago Up 24 minutes 0.0.0.0:32769-\u003e80/tcp sharp_jepsen [root@localhost ~]# docker commit -m \"Add tuzuoquan.txt\" -a \"toto-txt\" dfd1c30384f1 toto sha256:232eab347b5b848ef4484b47e912515b53b5f75af4d3ae507a0af6e42f10a46d -m:表示备注信息 -a:作者相关信息。 dfd1c30384f1：就是刚刚我们创建的容器ID toto: 表示生成的镜像名称： 当然我们不推荐这种方式，应该使用Dockerfile来操作的。后面才讲。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:8:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"查看本地文件一探究竟： [root@localhost ~]# cd /var/lib/docker/ [root@localhost docker]# ll total 8 drwx------. 20 root root 4096 Mar 12 17:11 containers ##容器运行相关信息 drwx------. 5 root root 50 Dec 17 22:59 devicemapper ##存储对应的存储池和相关的元数据 drwx------. 3 root root 25 Dec 17 22:52 image ##各层相关信息 drwxr-x---. 3 root root 18 Dec 17 22:52 network drwx------ 4 root root 30 Feb 21 14:26 plugins drwx------. 2 root root 6 Dec 19 11:54 swarm drwx------. 5 root root 96 Mar 12 16:57 tmp drwx------. 2 root root 6 Dec 17 22:52 trust drwx------. 15 root root 4096 Mar 3 00:45 volumes ##数据卷相关信息 docker login登录非docker hub仓库 使用语法：docker login [OPTIONS] [SERVER]，其中options的取值有三种：--password或者-p，表示密码；--password-stdin表示通过标准输入使用密码，这种使用方式输入密码时，不可见；--username或者-u，表示用户名。 一般-u和-p配合使用，默认情况下是通过标准输入来登录，即--password-stdin。例如： $ docker login -u test -p 123456 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:8:1","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"登录你自己的仓库 默认情况下，docker login会登录docker hub上的仓库。如果你想登录其他镜像仓库，你只需要在登录时将服务器名添加进去即可。 $docker login registry.csdn.com 登录完成后就可以在$HOME/.docker/config.json文件中找到你的相关认证信息，例如： { \"auths\": { \"https://index.docker.io/v1/\": { \"auth\": \"aJKvamllasdffzp6aGoxJKL2RTY=\" }, \"registry.csdn.com\": { \"auth\": \"aJKvamllasdffW86WmhqBNMyMzE2\" } }, \"HttpHeaders\": { \"User-Agent\": \"Docker-Client/18.06.1-ce (linux)\" } } ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:9:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"退出仓库 $docker logout registry.csdn.com 使用Dockerfile 创建镜像遇到的坑 当用Dockerfile去创建容器，步骤如下： ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:10:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"创建并编辑dockerfile mkdir mydocker cd /mydocker vim DockerFile (输入以下指令) FROM centos（指定其后构建新镜像所使用的基础镜像） VOLUME [\"/opt/dockerShare1\",\"/opt/dockerShare2\"]（容器中的挂载点） CMD echo \"finish scuess !!!!\"（指定在容器启动时所要执行的命令） CMD /bin/bash 保存退出 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:11:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"使用build命令 $ docker build -f /mydocker/Dockfile -t mycentos:1.01 # --tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 # -f :指定要使用的Dockerfile路径； 但是这里却报错了 \"docker build\" requires exactly 1 argument(s). 后面在官网看到这行 $ docker build -f dockerfiles/Dockerfile.debug -t myapp_debug . $ docker build -f dockerfiles/Dockerfile.prod -t myapp_prod . 大致意思是说： 此示例指定路径为.因此，本地目录中的所有文件都被排序并发送到Docker守护进程。该路径指定在何处找到Docker守护进程上构建的“上下文”的文件。 所以，要想用指定路径的Dockerfile构建，貌似必须用这个 . 。 Docker 容器日志 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:12:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"docker logs命令概述 docker logs: 获取容器的日志 语法： docker logs [OPTIONS] CONTAINER OPTIONS说明： -f : 跟踪日志输出 –since :显示某个开始时间的所有日志 -t : 显示时间戳 –tail :仅列出最新N条容器日志 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:13:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"docker logs实例 #跟踪查看容器mynginx的日志输出。 $ docker logs -f mynginx #查看容器mynginx从2016年7月1日后的最新10条日志。 docker logs --since=\"2016-07-01\" --tail=10 mynginx Docker 下的网络模式 构建容器的时候使用了--net anyesu_net这个选项, 意思是让容器使用自定义的网络 anyesu_net , 注意：Docker默认是根据容器运行的顺序设置IP的，所以会出现重启容器后IP改变的情况，以下是对Docker 下四种网络模式的一个简单介绍。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:14:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"bridge 这是 Docker 默认使用的模式, Docker Daemon 启动时默认会创建 Docker0 这个网桥, 网段为 172.17.0.0/16 , 宿主机 IP 为 172.17.0.1 , 作为这个虚拟子网的 网关 。 当然, 也可以新建一个名为 anyesu_net 网段为 172.18.0.0/16 的网桥： docker network create –subnet=172.18.0.0/16 anyesu_net 启动 容器 时指定 –net anyesu_net 即可。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:15:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"host 容器 共享 宿主机 的网络 ( IP 和 端口 ) 。使用 Docker 有相当一部分目的是为了隔离 宿主机 和 容器 , 使用 host 模式就违背了这一点, 不是很好。另外有很多 镜像 如 tomcat 默认监听 8080 端口的, 使用 host 模式后开多个 容器 就会造成端口冲突, 而不得不修改 tomcat 的监听端口。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:16:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"none 这种模式下, 创建的 容器 拥有自己的 Network Namespace, 但是没有任何网络配置, 所以默认是没有网络的, 可以自己对 容器 的 网卡、IP 进行配置, 适合用来配置比默认设置更加复杂的网络环境。 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:17:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"container 类似于 host 模式, 不过这种模式是共享已存在的 容器 使用的网络。 获取 docker 容器(container)的 ip 地址 进入容器内部后 #显示自己以及(– link)软连接的容器IP $ cat /etc/hosts 使用命令 $ docker inspect --format '{{ .NetworkSettings.IPAddress }}' \u003ccontainer-ID\u003e 或 $ docker inspect \u003ccontainer id\u003e 或 $ docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' container_name_or_id 可以考虑在 ~/.bashrc 中写一个 bash 函数： function docker_ip() { sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}' $1 } source ~/.bashrc 然后： $ docker_ip \u003ccontainer-ID\u003e 172.17.0.6 要获取所有容器名称及其IP地址只需一个命令。 docker inspect -f '{{.Name}} - {{.NetworkSettings.IPAddress }}' $(docker ps -aq) 如果使用docker-compose命令将是： docker inspect -f '{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -aq) 显示所有容器IP地址： docker inspect --format='{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -aq) 一些Docker命令 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:18:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Docker"],"content":"运行相关 # -t 终端 # -i 交互操作 docker run -it ubuntu /bin/bash # 后台运行一个容器 docker run -d -it ubuntu 附着到正在运行的容器, 附着完以后退出会导致容器也终止 docker attach 容器id 进入正在运行的 container 并且执行 $ docker exec -it 839a6cfc9496 /bin/bash #注意这里如果后面用exit命令退出容器，会导致容器也停止。正确的退出方式是按住Ctrl键+大写P+大写Q 在容器中运行一段程序 $ docker run ubuntu apt-get update 拷贝文件 #将容器中文件拷往主机 $ docker cp CONTAINER_ID:SRC_PATH DEST_PATH #eg：将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中 $ docker cp 96f7f14e99ab:/www /tmp/ #eg:将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www $ docker cp /www/runoob 96f7f14e99ab:/www # 从主机往容器中拷贝 $ docker cp SRC_PATH CONTAINER_ID:DEST_PATH # eg：将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下 $ docker cp /www/runoob 96f7f14e99ab:/www/ 参考链接 Docker 常见问题汇总(转) 一篇文章学会Docker命令 Docker入门-数据挂载 Docker - 挂载目录（bind mounts）和Volume是不同的 [Day 21] Docker (7) Docker: volume 使用 5. docker之挂载 ","date":"2020-04-25","objectID":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/:19:0","tags":["Docker"],"title":"Docker踩坑后的总结","uri":"/docker%E8%B8%A9%E5%9D%91%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93/"},{"categories":["技术","Nginx"],"content":"SSL/TLS ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:0:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"什么是 SSL/TLS  传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。网景公司（Netscape）在 1994 年推出首版网页浏览器，网景导航者时，推出 HTTPS 协议，以 SSL 进行加密，这是 SSL 的起源。IETF 将 SSL 进行标准化，1999 年公布第一版 TLS 标准文件。随后又公布 RFC 5246 （2008 年 8 月）与 RFC 6176 （2011 年 3 月）。 在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。主要的网站，如 Google、Facebook 等也以这个协议来创建安全连线，发送数据。当前已成为互联网上保密通信的工业标准。 ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:1:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"SSL/TLS 的版本 协议 发布时间 状态 SSL 1.0 未公布 未公布 SSL 2.0 1995 年 已于 2011 年弃用 SSL 3.0 1996 年 已于 2015 年弃用 TLS 1.0 1999 年 计划于 2020 年弃用 TLS 1.1 2006 年 计划于 2020 年弃用 TLS 1.2 2008 年 TLS 1.3 2018 年 ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:2:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"为什么要禁用 TLS1.0、TLS1.1  SSL 由于以往发现的漏洞，已经被证实不安全。而 TLS1.0 与 SSL3.0 的区别实际上并不太多，并且 TLS1.0 可以通过某些方式被强制降级为 SSL3.0。 由此，支付卡行业安全标准委员会（PCI SSC）强制取消了支付卡行业对 TLS 1.0 的支持，同时强烈建议取消对 TLS 1.1 的支持。 苹果、谷歌、微软、Mozilla 也发表了声明，将于 2020 年初放弃对 TLS 1.1 和 TLS 1.0 的支持。其原因是这两个版本使用的是过时的算法和加密系统，经发现，这些算法和系统是十分脆弱的，比如 SHA-1 和 MD5。它们也缺乏像完美的前向保密性这样的现代特征，并且容易受到降级攻击的影响。 ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:3:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"TLS 1.3 在2018年8月份，IETF终于宣布TLS 1.3规范正式发布了，标准规范（Standards Track）定义在 rfc8446。 ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:4:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"TLS 1.3 相较之前版本的优化内容有： **握手时间：**同等情况下，TLSv1.3 比 TLSv1.2 少一个 RTT **应用数据：**在会话复用场景下，支持 0-RTT 发送应用数据 **握手消息：**从 ServerHello 之后都是密文。 **会话复用机制：**弃用了 Session ID 方式的会话复用，采用 PSK 机制的会话复用。 总结一下就是在更安全的基础上还做到了更快，目前 TLS 1.3 的重要实现是 OpenSSL 1.1.1 开始支持了，在 Nginx 上的实现需要 Nginx 1.13+。 Brotli  Brotli 是由 Google 于 2015 年 9 月推出的无损压缩算法，它通过用变种的 LZ77 算法，Huffman 编码和二阶文本建模进行数据压缩，是一种压缩比很高的压缩方法，现代网站大多用的压缩算法都是 GZIP，它也是非常有效的一种压缩算法，可以节省网站服务器和用户之间传输数据所需要花费的时间，但是这个 Brotli，据闻能比 gzip 做得更好，不仅能获得更高的压缩比率，而且对压缩/解压速度影响也比较小，可以去谷歌的 GitHub 了解一下该项目 Brotli 具有如下特点: 针对常见的 Web 资源内容，Brotli 的性能要比 GZIP 好 17-25%； Brotli 压缩级别为 1 时，压缩速度是最快的，而且此时压缩率比 gzip 压缩等级为 9（最高）时还要高； 在处理不同 HTML 文档时，brotli 依然提供了非常高的压缩率; 在兼容 GZIP 的同时，相较 GZIP: JavaScript 上缩小 14% HTML上缩小 21% CSS上缩小 17%  Brotli 的支持必须依赖 HTTPS，不过换句话说就是只有在 HTTPS 下才能实现 Brotli。Brotli压缩可以和GZIP和谐共存，而且Brotli压缩效率要高于GZIP，因此推荐给服务器编译配置Brotli压缩。当同时开启Brotli跟GZIP两种压缩算法时，Brotli压缩等级优先级高于GZIP，并不会造成冲突。 安装 ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:4:1","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"下载源码 HTTP/2 要求 Nginx 1.9.5+，OpenSSL 1.0.2+ TLS 1.3 要求 Nginx 1.13+，OpenSSL 1.1.1及之后的版本+ Brotli 要求 HTTPS，并在 Nginx 中添加扩展支持 建议去官网随时关注最新版：Nginx，OpenSSL，ngx_brotil Nginx $ cd /opt $ wget -c https://nginx.org/download/nginx-1.16.1.tar.gz $ tar xzf nginx-1.16.1.tar.gz OpenSSL # 可以先查看已安装OpenSSL版本 $ openssl version -a OpenSSL 1.1.1d 10 Sep 2019 built on: Sun Mar 8 08:45:14 2020 UTC platform: linux-x86_64 options: bn(64,64) rc4(16x,int) des(int) idea(int) blowfish(ptr) compiler: gcc -fPIC -pthread -m64 -Wa,--noexecstack -Wall -O3 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -DNDEBUG OPENSSLDIR: \"/usr/local/openssl/ssl\" ENGINESDIR: \"/usr/local/openssl/lib/engines-1.1\" Seeding source: os-specific # 开始下载新版本 $ cd /opt $ wget https://www.openssl.org/source/openssl-1.1.1f.tar.gz $ tar xzf openssl-1.1.1f.tar.gz Brotli $ cd /opt $ git clone https://github.com/google/ngx_brotli.git $ cd ngx_brotli $ git submodule update --init ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:5:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"编译以及安装 $ nginx -V 先用使用以上命令查询出已有nginx有安装的模块以及配置的路径，之后再原有的基础上增加 --prefix=/usr/local/nginx \\ ## 编译后安装的目录位置，可以替换成跟原来一样 --with-openssl=/opt/openssl-1.1.1f \\ ## 指定单独编译入 OpenSSL 的源码位置 --with-openssl-opt=enable-tls1_3 \\ ## 开启 TLS 1.3 支持 --with-http_v2_module \\ ## 开启 HTTP/2 --with-http_ssl_module \\ ## 开启 HTTPS 支持 --with-http_gzip_static_module \\ ## 开启 GZIP 压缩 --add-module=/opt/ngx_brotli ## 编译入 ngx_BroTli 扩展 综合两者，最后编译Nginx $ cd /opt/nginx-1.16.1 $ ./configure \\ --prefix=/etc/nginx \\ --sbin-path=/usr/sbin/nginx \\ --modules-path=/usr/lib64/nginx/modules \\ --conf-path=/etc/nginx/nginx.conf \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --pid-path=/var/run/nginx.pid \\ --lock-path=/var/run/nginx.lock \\ --http-client-body-temp-path=/var/cache/nginx/client_temp \\ --http-proxy-temp-path=/var/cache/nginx/proxy_temp \\ --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \\ --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \\ --http-scgi-temp-path=/var/cache/nginx/scgi_temp \\ --user=nginx \\ --group=nginx \\ --with-compat \\ --with-file-aio \\ --with-threads \\ --with-http_addition_module \\ --with-http_auth_request_module \\ --with-http_dav_module \\ --with-http_flv_module \\ --with-http_gunzip_module \\ --with-http_gzip_static_module \\ --with-http_mp4_module \\ --with-http_random_index_module \\ --with-http_realip_module \\ --with-http_secure_link_module \\ --with-http_slice_module \\ --with-http_ssl_module \\ --with-http_stub_status_module \\ --with-http_sub_module \\ --with-http_v2_module \\ --with-mail \\ --with-mail_ssl_module \\ --with-stream \\ --with-stream_realip_module \\ --with-stream_ssl_module \\ --with-stream_ssl_preread_module \\ --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC' \\ --with-ld-opt='-Wl,-z,relro -Wl,-z,now -pie' \\ --with-openssl=/opt/src/openssl-1.1.1f \\ --with-openssl-opt=enable-tls1_3 \\ --add-module=/opt/src/ngx_brotli # 编译并安装 $ make \u0026\u0026 make install Nginx配置 HTTP2 listen 443 ssl http2; 只要在 server{} 下的lisen 443 ssl 后添加 http2 即可。而且从 1.15 开始，只要写了这一句话就不需要再写 ssl on 了。 只开启TLS 1.2与TLS1.3 ssl_protocols TLSv1.2 TLSv1.3; 然后我们再修改对应的加密算法算法： ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384; 默认情况下 Nginx 因为安全原因，没有开启 TLS 1.3 0-RTT，可以通过添加 ssl_early_data on; 指令开启 0-RTT的支持。 Brotli 只需要在对应配置文件中，添加下面代码即可： brotli on; brotli_comp_level 6; brotli_min_length 1k; brotli_types text/plain text/css text/xml text/javascript text/x-component application/json application/javascript application/x-javascript application/xml application/xhtml+xml application/rss+xml application/atom+xml application/x-font-ttf application/vnd.ms-fontobject image/svg+xml image/x-icon font/opentype; 下面放一个完整的server{}供大家参考： server { listen 443 ssl http2; # 开启 http/2 server_name chenjunxin.com; #证书部分 ssl_certificate cert/3475595_www.chenjunxin.com.pem; ssl_certificate_key cert/3475595_www.chenjunxin.com.key; #TLS 握手优化 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; keepalive_timeout 75s; keepalive_requests 100; #TLS 版本控制 ssl_protocols TLSv1.2 TLSv1.3; # Requires nginx \u003e= 1.13.0 else use TLSv1.2 ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384; #服务端加密算法优先 ssl_prefer_server_ciphers on; #开启1.3 0-RTT ssl_early_data on; # GZip 和 Brotli gzip on; gzip_comp_level 6; gzip_min_length 1k; gzip_types text/plain text/css text/xml text/javascript text/x-component application/json application/javascript application/x-javascript application/xml application/xhtml+xml application/rss+xml application/atom+xml application/x-font-ttf application/vnd.ms-fontobject image/svg+xml image/x-icon font/opentype; brotli on; brotli_comp_level 6; brotli_min_length 1k; brotli_types text/plain text/css text/xml text/javascript text/x-component application/json application/javascript application/x-javascript application/xml","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:6:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"OSCP 在Nginx配置中开启OSCP配置，可以在以上的ssllabs.com的检测信息中看到: ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:7:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"HTTP/2 通过浏览器的开发者工具，我们可以在Network栏目中看到Protocol中显示 h2有无来判断。 ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:8:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"TLS 1.3 目前主流的浏览器都支持 TLS 1.3 版本： Chrome 从 62 版本默认开启 TLS 1.3 的支持，如果是 62 以下的版本，可以进行下列的配置 工具栏上打开 chrome://flags/ 启用 TLS 1.3 Firefox 从 47 版本默认开启 TLS 1.3 的支持，如果是 47 以下的版本，可以进行下列的配置。 工具栏上打开 about:config 修改 security.tls.version.max 为 4 重新启动浏览器 然后可以通过浏览器的开发者工具中的Security栏目看到Connection栏目下是否有显示 TLS 1.3 ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:9:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"HSTS Nginx配置中设置了HSTS，这使得服务器每次response都告诉浏览器所有请求都强制使用https，就算用户手动输入http 地址也会在浏览器内部替换为https 请求，在根源上杜绝浏览器与服务器建立非安全连接。 ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:10:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["技术","Nginx"],"content":"Brotli 通过浏览器的开发者工具，我们可以在 Network 栏目中，打开具体页面的头信息，看到 **accept-encoding **中有 br 字眼就行。 参考链接 Nginx 上部署 TLS1.3、Brotli、ECC双证书实践 TLS1.3正式更新，为Nginx添加TLS1.3的支持 Nginx禁用TLS1.0与1.1的尝试 让Nginx快速支持TLS1.3协议 我博客的nginx配置文件详解 使用 OCSP Stapling 来优化 SSL 的速度与隐私安全 Strong SSL Security on nginx TLS / SSL密码强化的建议 Nginx 配置双证书（RSA、ECC） ","date":"2020-04-08","objectID":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/:11:0","tags":["Nginx","TLS","Brotil"],"title":"Nginx上部署TLS1.3和Brotli","uri":"/nginx%E4%B8%8A%E9%83%A8%E7%BD%B2tls1-3%E5%92%8Cbrotli/"},{"categories":["工具","图片压缩","WebP"],"content":"WebP是一种相对较新的开源图像格式，它为Google设计的网页上的图像提供了卓越的无损和有损压缩。","date":"2020-03-21","objectID":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/","tags":["图片压缩"],"title":"使用Google官方推荐的webp进行图片压缩","uri":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"},{"categories":["工具","图片压缩","WebP"],"content":"WebP介绍  WebP是一种相对较新的开源图像格式，可为Web上的图像提供出色的无损和有损压缩。 使用WebP，网站管理员和Web开发人员可以创建更小，更丰富的图像，从而使Web更快。 与PNG相比，WebP无损图像的尺寸要小26％。 在同等的SSIM质量指数下，WebP有损图像比同类JPEG图像小25-34％。无损WebP支持透明性（也称为Alpha通道），而仅增加了22％的字节数。 对于可以接受有损RGB压缩的情况，有损WebP还支持透明性，与PNG相比，文件大小通常小3倍。 既然我们已经认识到在可能的情况下使用WebP格式是有价值的，那么很重要的一点是—它不能完全替代 JPEG 和 PNG，因为浏览器对 WebP 支持并不完全普及。 在撰写本文时，Safari 和 旧的IE 都是不支持WebP的浏览器。 根据 caniuse.com 的数据，全球有77.63%的用户使用支持WebP的浏览器。这意味着，通过使用 WebP 图像，可以为77.63% 的用户提供更快的 web 页面及更好的体验。 要使用它，需要下载适用于Linux，Windows和Mac OS X的预编译的实用程序。 Linux中安装使用WebP工具 ","date":"2020-03-21","objectID":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/:0:0","tags":["图片压缩"],"title":"使用Google官方推荐的webp进行图片压缩","uri":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"},{"categories":["工具","图片压缩","WebP"],"content":"安装WebP Manjaro/ArchLinux系统下,直接在终端运行命令安装就可以了: $ sudo pacaman -S libwebp 在Linux发行版上，首先从Google Googles存储库下载webp包，如下所示。 $ wget -c https://storage.googleapis.com/downloads.webmproject.org/releases/webp/libwebp-1.1.0-linux-x86-64.tar.gz 或者 $ curl -c https://storage.googleapis.com/downloads.webmproject.org/releases/webp/libwebp-1.1.0-linux-x86-64.tar.gz 然后解压该文件并进入解压缩的包目录中: $ tar -xvf libwebp-1.1.0-linux-x86-64.tar.gz $ cd libwebp-1.1.0-linux-x86-64/ $ cd bin/ $ ls Webp软件包 该软件包包含一个预编译库（ libwebp ），用于将webp编码或解码以及其他各种webp实用程序。 anim_diff - 显示动画图像之间差异 anim_dump - 转储动画图像之间差异 cwebp - webp编码器 dwebp - webp解码器 gif2webp - 将GIF图像转换为webp img2webp - 用于将一系列图像转换为动画webp文件的工具。 vwebp - webp文件查看器 webpinfo - 用于查看有关webp图像文件的信息 webpmux - 用于从静态的webp images创建动态的webp，或者从动态的webp提取静态的webp images ","date":"2020-03-21","objectID":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/:1:0","tags":["图片压缩"],"title":"使用Google官方推荐的webp进行图片压缩","uri":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"},{"categories":["工具","图片压缩","WebP"],"content":"WebP转换实例 将webp工具目录添加至PATH中，编辑~/.bashrc添加以下内容： export PATH=$PATH:~/libwebp-1.1.0-linux-x86-64/bin 保存该文件并退出。 然后在终端执行source ~/.bashrc。 ","date":"2020-03-21","objectID":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/:2:0","tags":["图片压缩"],"title":"使用Google官方推荐的webp进行图片压缩","uri":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"},{"categories":["工具","图片压缩","WebP"],"content":"cwebp使用 将一个图像文件压缩成一个webp文件，输入文件可以是PNG,JPEG,TIFF,WebP等等。 语法： cwebp [options] input_file -o output_file.webp 选项 -o string 指定输出文件名 -h，-help 简单的使用说明 -H，-longhelp 详细的使用说明 -version 版本号 -lossless 对图像进行无损编码 -q float 指定压缩因素，范围是0-100，默认为75 -z int 在0-9之间切换无损耗压缩模式，0级最快，9级最慢。快速模式产生的文件大小比较慢的文件要大。默认是6。如果-q或者-m之后被使用，-z将无效。 -mt 如果可能的话，使用多线程编码 -low_memory 减少对有损编码的内存使用。 -f int 指定过滤器的强度，范围在0(不过滤)-100(最大过滤)，值越高图像就越平滑，典型的值通常在20-50之间。 -sns int 指定空间噪声形成的振幅，范围为0(弱)-100(强)，默认为50。 -progress 报告编码进展百分比。 例子: $ cwebp images/flower.jpg -o images/flower.webp # 转换单个文件 $ cwebp -q 50 -lossless picture.png -o picture_lossless.webp # 将picture.png以50的质量无损转换为webp $ cwebp -q 70 picture_with_alpha.png -o picture_with_alpha.webp $ cwebp -sns 70 -f 50 picture.png -o picture.webp $ for file in ~/temp/*; do cwebp -lossless \"$file\" -o \"${file%.*}.webp\";done # 无损转换整个目录下的文件 # 推荐 将quality设置为85会生成质量与PNG相当但小得多的WebP图像。对于jpeg，将quality设置为75可以在视觉和文件大小之间取得很好的平衡。 $ cwebp -q 75 picture_with_alpha.jpg -o picture_with_alpha.webp $ cwebp -q 85 picture_with_alpha.png -o picture_with_alpha.webp # 使用vwebp工具查看转换后的webp图像 $ vwebp picture_lossless.webp 编码器，标准和高级选项文档 dwebp使用 将WebP文件解压成一个图像文件，类型可以是JPG，PNG，PAM，PPM，PGM等等。 语法： dwebp [options] input_file.webp 选项 -h 打印用法总结。 -version 打印版本号。 -o string 指定输出文件名 -bmp 将输出格式更改为未压缩的BMP。 -tiff 将输出格式更改为未压缩的TIFF。 -pam 将输出格式更改为PAM(保留alpha)。 -ppm 将输出格式更改为PPM(丢弃alpha)。 -pgm 将输出格式更改为PGM。 $ dwebp image.webp -o image.png 解码器，命令行选项文档 更多WebP的使用 https://developers.google.com/speed/webp/docs/using 参考链接 WebP官方转换工具手把手安装教程 WebP - Mac上使用cwebp,dwebp,webpmux工具 如何在Linux中将图像转换为WebP格式 用 WebP 作为你的首选图片文件格式 Web 性能优化： 图片优化让网站大小减少 62% ","date":"2020-03-21","objectID":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/:3:0","tags":["图片压缩"],"title":"使用Google官方推荐的webp进行图片压缩","uri":"/%E4%BD%BF%E7%94%A8google%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84webp%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"},{"categories":["技术","密码学"],"content":"哈希与加密的区别 首先要了解哈希（Hash）和加密（Encrypt）的区别，正确区别两者是正确选择和使用哈希与加密的基础。 概括来说，哈希（Hash）是将目标文本转换成具有相同长度的、不可逆的杂凑字符串（或叫做消息摘要），而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。 具体来说，两者有如下重要区别： 哈希算法往往被设计成生成具有相同长度的文本，而加密算法生成的文本长度与明文本身的长度有关。 例如，设我们有两段文本：“Microsoft”和“Google”。两者使用某种哈希算法得到的结果分别为：“140864078AECA1C7C35B4BEB33C53C34”和“8B36E9207C24C76E6719268E49201D94”，而使用某种加密算法的到的结果分别为“Njdsptpgu”和“Hpphmf”。可以看到，哈希的结果具有相同的长度，而加密的结果则长度不同。实际上，如果使用相同的哈希算法，不论你的输入有多么长，得到的结果长度是一个常数，而加密算法往往与明文的长度成正比。 哈希算法是不可逆的，而加密算法是可逆的。 这里的不可逆有两层含义，一是“给定一个哈希结果R，没有方法将E转换成原目标文本S”，二是“给定哈希结果R，即使知道一段文本S的哈希结果为R，也不能断言当初的目标文本就是S”。其实稍微想想就知道，哈希是不可能可逆的，因为如果可逆，那么哈希就是世界上最强悍的压缩方式了——能将任意大小的文件压缩成固定大小。 加密则不同，给定加密后的密文R，存在一种方法可以将R确定的转换为加密前的明文S。 哈希与加密的数学基础 从数学角度讲，哈希和加密都是一个映射。下面正式定义两者： 一个哈希算法$R=H(S)$是一个多对一映射，给定目标文本S，H可以将其唯一映射为R，并且对于所有S，R具有相同的长度。由于是多对一映射，所以H不存在逆映射$S=H^{-1}(R)$使得R转换为唯一的S。 一个加密算法$R=E(S,K_E)$是一个一一映射，其中第二个参数叫做加密密钥，E可以将给定的明文S结合加密密钥Ke唯一映射为密文R，并且存在另一个一一映射$S=D(R,K_D)$，可以结合Kd将密文R唯一映射为对应明文S，其中Kd叫做解密密钥。 由于哈希算法的定义域是一个无限集合，而值域是一个有限集合，将无限集合映射到有限集合，每个哈希结果都存在无数个可能的目标文本，因此哈希不是一一映射，是不可逆的。 而加密算法是一一映射，因此理论上来说是可逆的。 哈希算法(摘要算法) 常见的Hash算法有MD5(Message-Digest Algorithm)和SHA(Secure Hash Algorithm)。SHA又包括 SHA-1 和 SHA-2(SHA-224、SHA-256、SHA-384、SHA-512) 和SHA-3。 MD5是输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算，得出结果。 SHA-1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5（更早之前被广为使用的散列函数）的后继者。 SHA-2它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。 由于对MD5出现成功的破解，以及对SHA-1和SHA-2出现理论上破解的方法，NIST感觉需要一个与之前算法不同的，可替换的加密杂凑算法，也就是现在的SHA-3。 ","date":"2020-03-03","objectID":"/md5-sha-gpg%E5%92%8Cpgp/:0:0","tags":["MD5","SHA","PGP","GPG"],"title":"MD5,SHA,GPG和PGP","uri":"/md5-sha-gpg%E5%92%8Cpgp/"},{"categories":["技术","密码学"],"content":"SHA算法家族哈希值大小及输出长度: SHA-1算法的哈希值大小为160位，其计算输出长度为40位16进制字符串。 SHA-224算法的哈希值大小为224位，其计算输出长度为56位16进制字符串。 SHA-256算法的哈希值大小为256位，其计算输出长度为64位16进制字符串。 SHA-384算法的哈希值大小为384位，其计算输出长度为96位16进制字符串。 SHA-512算法的哈希值大小为512位，其计算输出长度为128位16进制字符串。 ","date":"2020-03-03","objectID":"/md5-sha-gpg%E5%92%8Cpgp/:1:0","tags":["MD5","SHA","PGP","GPG"],"title":"MD5,SHA,GPG和PGP","uri":"/md5-sha-gpg%E5%92%8Cpgp/"},{"categories":["技术","密码学"],"content":"SHA1与MD5算法比较 SHA1和MD5做为两种单向散列算法，二者均由MD4算法延伸导出，它们的强度及相关特性也非常相似。两者的区别主要体现以下几点： SHA1防碰撞性更好：两者最主要的区别还在于SHA1要比MD5摘要要长 32位。单从强行攻击角度来说，要破结一个MD5哈希摘要报文，其需要操作的数量级为$2^{128}$。而对于SHA1哈希摘要报文，其所需的数量级为$2^{160}$。从这方面来说，SHA1具有更好的抗强行攻击安全性。 MD5运算速度更快：由于MD5比SHA1更短，在相同的硬件上，计算MD5哈希摘要要 比计算SHA1哈希摘要速度更快。 SHA1相对安全：SHA1MD5，而MD5在设计方面也易受密码分析的攻击，理论上讲SHA1的安全性要高于MD5。 ","date":"2020-03-03","objectID":"/md5-sha-gpg%E5%92%8Cpgp/:2:0","tags":["MD5","SHA","PGP","GPG"],"title":"MD5,SHA,GPG和PGP","uri":"/md5-sha-gpg%E5%92%8Cpgp/"},{"categories":["技术","密码学"],"content":"MD5,SHA实际应用 Git的分支版本号管理就是用了SHA-1根据内容改变生成一串消息摘要。 使用git中的hash命令也可以查看指定文件的sha-1值: $ git hash-object README.md a13c2dba7f888de53aa3e84e69e8a131109bbfc8 那么Git是否考虑到SHA1碰撞的问题，可以看这里 Docker中经常使用的生成各种UUID的是SHA-256算法，例如镜像层ImageID,容器ID。所有镜像层和容器层都保存在宿主机的文件系统/var/lib/docker/中，由存储驱动进行管理。 Linux下校验下载文件的完整性(MD5,SHA256) MD5校验 #直接输出MD5 Hash $ md5sum your-downloaded-file-name fd4a1b802373c57c10c926eb7ac823d8 your-downloaded-file-name #当前目录下所有文件生成MD5 Hash $ md5sum * | tee hi.md5 #将MD5 Hash值保存到md5-hash.txt文件中. $ md5sum your-downloaded-file-name \u003e md5-hash.txt # 显示输出的md5-hast.txt内容 $ cat md5-hash.txt fd4a1b802373c57c10c926eb7ac823d8 your-downloaded-file-name # 通过md5-hash.txt来校验你下载的文件是否正确 $ md5sum -c md5-hash.txt your-downloaded-file-name: OK 你是文件的发布者话，你可以通过md5sum把文件的哈希值发送给验证者，这样下载你文件的人就可以通过MD5哈希值来验证你的文件正确性。反过来，我们在网站上下载文件之后，同时可以获取发布者的MD5哈希值和本地生成的Hash值对比，如果一致，认为文件是正确的。 SHA265校验 原理： 原理同MD5一样，都是通过对文件进行HASH求值，比对文件发布者发布的HASH值，通过是否相等判断文件是否被篡改。 sha256sum 命令 和 md5sum 命令一样的功能，只是使用算法不同，sha256相对 md5sum 更为准确，所以现在很多的系统的发行版都是使用 sha256sum 进行校验！实际例子：Kali Linux $ sha256sum kali-linux-light-2018.2-amd64.iso 554f020b0c89d5978928d31b8635a7eeddf0a3900abcacdbc39616f80d247f86 kali-linux-light-2018.2-amd64.iso 对称加密和非对称加密 对称加密：指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。 常见的对称加密算法：DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6 和 AES等。 非对称加密：指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。 举个例子，你向某公司服务器请求公钥，服务器将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人才能对你的消息解密。与对称加密不同的是，公司服务器不需要将私钥通过网络发送出去，因此安全性大大提高。最常用的非对称加密算法：RSA、ECC （移动设备用）、Diffie-Hellman、El Gamal、DSA （数字签名用） 对称加密优缺点：对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。 非对称加密优缺点：安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 总结：安全肯定是非对称加密安全，但是效率比较慢，对称加密效率高，但是不安全。严谨一点的做法是混合起来使用，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。实际工作中直接使用非对称加、解密其实也可以，因为我们平时一般请求的报文不会很大，加解密起来速度在可接受范围内，或者可以对敏感字段，比如密码、手机号、身份证号等进行分段加密，效率还可以。 PGP和GPG ","date":"2020-03-03","objectID":"/md5-sha-gpg%E5%92%8Cpgp/:3:0","tags":["MD5","SHA","PGP","GPG"],"title":"MD5,SHA,GPG和PGP","uri":"/md5-sha-gpg%E5%92%8Cpgp/"},{"categories":["技术","密码学"],"content":"什么是PGP PGP（Pretty Good Privacy）是一套用于讯息加密、验证的应用程序，采用IDEA的散列算法作为加密和验证之用。 PGP加密由一系列散列、数据压缩、对称密钥加密，以及公钥加密的算法组合而成。每个步骤均支持几种算法，用户可以选择一个使用。每个公钥均绑定一个用户名和/或者E-mail地址。 PGP的主要开发者是菲尔·齐默曼（Phil Zimmermann）。齐默曼于1991年将PGP在互联网上免费发布。PGP本身是商业应用程序；开源并具有同类功能的工具名为GnuPG（GPG）。PGP及其同类产品均遵守OpenPGP数据加解密标准。 ","date":"2020-03-03","objectID":"/md5-sha-gpg%E5%92%8Cpgp/:4:0","tags":["MD5","SHA","PGP","GPG"],"title":"MD5,SHA,GPG和PGP","uri":"/md5-sha-gpg%E5%92%8Cpgp/"},{"categories":["技术","密码学"],"content":"什么是GPG GnuPG（GNU Privacy Guard，GPG）是一种加密软件，它是PGP加密软件的开源替代物。GnuPG依照由IETF制定的OpenPGP技术标准设计。GnuPG是用于加密、数字签章及产生非对称匙对的软件。GPG 兼容 PGP（Pretty Good Privacy）的功能。 ","date":"2020-03-03","objectID":"/md5-sha-gpg%E5%92%8Cpgp/:5:0","tags":["MD5","SHA","PGP","GPG"],"title":"MD5,SHA,GPG和PGP","uri":"/md5-sha-gpg%E5%92%8Cpgp/"},{"categories":["技术","密码学"],"content":"GPG实际应用 尽管MD5,SHA等哈希函数就可以用于日常校验安装包是否被改变过，但是还是有一定的可能性发生修改后的数据包哈希结果的值还是和之前相同，而且也无法证明这个包就是特定的某个人或者特定的官方机构发出来的。所以用到了GPG来进一步签名认证。 Github 使用 GPG 签名验证一般Linux发行版都包含GPG软件包，可以通过发行版的包管理器来安装（一般发行版都会默认安装，因为这个软件太重要了）。使用下面的命令确认当前系统是否安装了GPG $ gpg --version ","date":"2020-03-03","objectID":"/md5-sha-gpg%E5%92%8Cpgp/:6:0","tags":["MD5","SHA","PGP","GPG"],"title":"MD5,SHA,GPG和PGP","uri":"/md5-sha-gpg%E5%92%8Cpgp/"},{"categories":["技术","密码学"],"content":"常规操作 生成密钥 ## 生成新的密钥对 $ gpg --gen-key $ gpg --generate-key ## 以全功能形式生成新的密钥对（期间会有一些密钥的配置） $ gpg --full-generate-key $ gpg --full-gen-key 列出密钥 #列出公钥 $ gpg --list-keys $ gpg --list-key [用户ID] #列出私钥 $ gpg --list-secret-keys 参考链接 哈希(Hash)与加密(Encrypt)的基本原理、区别及工程应用 哈希算法与MD5、SHA md5sum 和 sha256sum用于 验证软件完整性 Linux下校验下载文件的完整性(MD5,SHA1,PGP) 对称加密、非对称加密、RSA(总结) Github 使用 GPG 签名验证 GPG使用教程 GPG 与端到端加密：论什么才是可以信任的 ","date":"2020-03-03","objectID":"/md5-sha-gpg%E5%92%8Cpgp/:6:1","tags":["MD5","SHA","PGP","GPG"],"title":"MD5,SHA,GPG和PGP","uri":"/md5-sha-gpg%E5%92%8Cpgp/"},{"categories":["技术","博客优化"],"content":"之前搭建Hexo的时候也有借用一些插件实现图片懒加载以及图片压缩的功能优化了一下，不过最近刚好了解了下HTTP2,就想着从网络协议层面优化看看。","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"HTTP 协议 HTTP 协议是 HyperText Transfer Protocol（超文本传输协议）的缩写，它是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。 HTTP的基本优化 影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。 延迟： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。 HTTP/1.x 的缺陷 连接无法复用：连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。 HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。 HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片(浏览器或者客户端是根据域名来建立连接的。比如针对Example Domain只允许同时建立2个连接，但mobile.example.com被认为是另一个域名，可以再建立两个新的连接。依次类推，如果我再多建立几个sub domain（子域名），那么同时可以建立的http请求就会更多，这就是域名分片了。连接数变多之后，受限制的请求就不需要等待前面的请求完成才能发出了。这个技巧被大量的使用，一个颇具规模的网页请求数可以超过100，使用域名分片之后同时建立的连接数可以多到50个甚至更多)等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。 Head-Of-Line Blocking（HOLB）：导致带宽无法被充分利用，以及后续健康请求被阻塞。HOLB是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。 HTTP 1.0：下个请求必须在前一个请求返回后才能发出，request-response对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。 HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片）。 协议开销大： HTTP1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。 安全因素：HTTP1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。 HTTP/2 简介 2015 年，HTTP/2 发布。HTTP/2 是现行 HTTP 协议（HTTP/1.x）的替代，但它不是重写，HTTP 方法/状态码/语义都与 HTTP/1.x 一样。HTTP/2 基于 SPDY3，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）。HTTP2.0 支持明文 HTTP 传输。 HTTP2.0和HTTP1.X相比的新特性 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。可以通过链接直观感受下 HTTP/2 比 HTTP/1 到底快了多少。 header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，对于相同的数据,不再通过每次请求和响应发送,既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），即服务端能通过 push 的方式将客户端需要的内容预先推送过去，也叫“cache push”。可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。 HTTP2的升级改造 HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。 当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了。 使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。 ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:0:0","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"获取SSL证书 参考这篇文章里的方式获取免费的SSL证书，然后再配置域名解析HTTPS，还要在服务器的Nginx上配置我是用了阿里云的一年免费的那个。 ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:1:0","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"给域名添加DNS CAA记录 ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:2:0","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"什么是CAA DNS Certification Authority Authorization（DNS证书颁发机构授权，简称 CAA）是一项借助互联网的域名系统（DNS），使域持有人可以指定允许为其域签发证书的数字证书认证机构（CA）的技术。它会在 DNS 下发 IP 的同时，同时下发一条资源记录，标记该域名下使用的证书必须由某证书颁发机构颁发。由于一个域名可以在很多家数字证书厂商CA申请SSL证书，如果域名被劫持很有可能在域名持有者不知情的情况下申请一张受浏览器信任的证书。同时对于CA来说，如果某个域名已经制定了哪家CA给自己颁发ssl证书，那么其他家就无法给这个域名颁发证书了，这样可以有效保护SSL证书的随意申请和滥用。 简单地说，就是当域名的 DNS 解析存在 CAA 记录时，则只允许在记录中列出的 CA 机构颁发针对该域名(或子域名)的证书。CAA 记录可以控制单域名 SS L证书的发行，也可以控制通配符证书。 所以设置了 CAA，如果有一天想更换非 CAA 记录中的 CA，要记得把 DNS CAA 的解析记录消掉。否则颁发会失败。 ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:2:1","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"在域名的DNS添加CAA 目前国内的云服务中，阿里云支持 CAA 的 DNS 解析，因为本人用的阿里云，所以其它云服务产商不太了解，在 DNS 解析处看看就知道支持不支持了，如果不支持想添加的话也可以换用支持的 DNS 服务商来解决。打开阿里云控制面板，找到要解析的域名，然后点击“解析”，具体如下图： 关于记录值，可以使用CAA Record Helper 来自动生成。将生成的记录值（比如0 issue \"chenjunxin.com\"这样的）填入到 DNS 解析中。 成功添加CAA记录后，可以通过sslab扫描，开启成功后检查结果如下： ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:2:2","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"Nginx上配置HTTP2 这里很简单，在已经配置好的HTTPS 443端口监听的后面添加http2就可以了，如下： server { - listen 443 ssl; + listen 443 ssl http2; server_name localhost; ssl on; ssl_certificate /etc/nginx/certs/example.crt; ssl_certificate_key /etc/nginx/certs/example.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { root /usr/share/nginx/html; index index.html index.htm; } } ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:3:0","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"效果对比 然后我们先看一下传输的流量节省了多少，如下图所示，加载一个页面： 可以看到，HTTP 2在流量方面并没有太大的改进，只减少了4kB（1%）的流量，下面我们再分析原因。HTTP 2的优势还在于它的多路复用等方面。 使用Chrome浏览器开发者工具的Audits功能给网页进行评分的对比，左边是没有开启HTTP2的结果，评分之后有提示可以开启HTTP2进行优化: ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:4:0","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"其他优化 ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:5:0","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"Nginx 开启 GZIP GZIP 能有效减少网络传输消耗，开启以后会占用一点服务器的 CPU，对前端网页性能提升有一些帮助。例如: http { include mime.types; default_type application/octet-stream; charset UTF-8; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 60; #... ...# gzip on; gzip_vary on; gzip_comp_level 6; gzip_buffers 16 8k; gzip_min_length 1000; gzip_proxied any; gzip_disable \"msie6\"; gzip_http_version 1.0; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml; #... ...# include /home/jerry/www/nginx_conf/*.conf; } ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:5:1","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","博客优化"],"content":"图片优化 图片格式用 WebP，图片缩放到合适大小，图片用 lazy-load。 参考链接 博客跑分优化 一文读懂 HTTP/2 及 HTTP/3 特性 HTTP/2 相比 1.0 有哪些重大改进? 怎样把网站升级到http/2 HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 Nginx 下实现 HTTP/2 服务器推送 (Server Push) 教程 ","date":"2020-03-02","objectID":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/:6:0","tags":["博客优化","HTTP2"],"title":"博客优化记录","uri":"/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"},{"categories":["技术","NodeJS"],"content":"NodeJS npm卸载 先删除一次 $ sudo npm uninstall npm -g 或 $ yum remove nodejs npm -y 手动删除残留 进入 /usr/local/lib 删除所有 node 和 node_modules文件夹 进入 /usr/local/include 删除所有 node 和 node_modules 文件夹 检查 ~ 文件夹里面的\"local” “lib” “include” 文件夹，然后删除里面的所有 “node” 和 “node_modules” 文件夹 可以使用以下命令查找 $ find ~/ -name node $ find ~/ -name node_modules 进入 /usr/local/bin 删除 node 的可执行文件 删除: /usr/local/bin/npm 删除: /usr/local/share/man/man1/node.1 删除: /usr/local/lib/dtrace/node.d 删除: rm -rf /home/[homedir]/.npm 删除: rm -rf /home/root/.npm 验证是否成功 如果上述你已经按照顺序去执行一遍了，那我们就需要来验证一下我们有没有删除成功。如果出现以下结果说明我们就是删除成功了。 $ node -v //not found $ npm -v //not found 安装NodeJS步骤 wget命令下载Node.js安装包。 选择自己需要安装的版本https://nodejs.org/dist/ 选择带linux-x64.tar.xz的安装包，该安装包是编译好的文件，解压之后，在bin文件夹中就已存在node和npm，无需重复编译。 $ wget https://nodejs.org/dist/v12.16.1/node-v12.16.1-linux-x64.tar.xz 如果提示找不到wget命令,可以先安装weget,执行yum -y install wget后再安装。 2. 解压文件。 $ tar xvf node-v12.16.1-linux-x64.tar.xz 创建软链接，使node和npm命令全局有效 通过创建软链接的方法，使得在任意目录下都可以直接使用node和npm命令。 软件默认安装在/目录或者~目录下，也就是根目录或当前用户目录，如果不清楚当前的目录可以执行pwd命令。如果需要将该软件安装到其他目录（如：/opt/node/）下，请进行如下操作： # 创建目录 $ mkdir -p /opt/node/ # 移动到目录中 $ sudo mv /home/chenjunxin/node-v12.16.1-linux-x64/* /opt/node/ # 创建新的软链 sudo ln -s /opt/node/bin/node /usr/local/bin/node sudo ln -s /opt/node/bin/npm /usr/local/bin/npm 查看node、npm版本。 $ node -v $ npm -v npm安装慢或者被墙问题解决办法 因为npm存储包文件的服务器在国外，有时候会被墙，或者下载速度较慢，所以我们需要解决这个问题。 淘宝的开发团队把npm在国内做了一个npm镜像备份，每10分钟会把国外npm的第三方包同步到淘宝自己服务器。 也可以选择安装淘宝的cnpm： # --global 表示安装到全局，而非当前目录 $ npm install --global cnpm # 设置全局软链 $ sudo ln -s /opt/node/bin/cnpm /usr/local/bin/cnpm # 查看版本信息 $ cnpm -v 接下来你安装包的时候把之前的npm替换成cnpm既可。 查看和设置npm镜像地址 ","date":"2020-03-01","objectID":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/:0:0","tags":["NodeJS","npm"],"title":"CentOS7.x重装配置NodeJS和npm","uri":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/"},{"categories":["技术","NodeJS"],"content":"查看配置 $ npm config list ","date":"2020-03-01","objectID":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/:1:0","tags":["NodeJS","npm"],"title":"CentOS7.x重装配置NodeJS和npm","uri":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/"},{"categories":["技术","NodeJS"],"content":"设置镜像 常用的 npm 镜像地址有： npm (默认) cnpm taobao nj rednpm npmMirror edunpm 临时使用 $ npm --registry https://registry.npm.taobao.org install xxx 持久使用 $ npm config set registry https://registry.npm.taobao.org $ npm config set disturl https://npm.taobao.org/dist 或者直接编辑 ~/.npmrc 文件，加入如下内容： registry = https://registry.npm.taobao.org disturl https://npm.taobao.org/dist 检测镜像是否配置成功 $ npm config get registry $ npm config get disturl ","date":"2020-03-01","objectID":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/:2:0","tags":["NodeJS","npm"],"title":"CentOS7.x重装配置NodeJS和npm","uri":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/"},{"categories":["技术","NodeJS"],"content":"删除镜像 $ npm config delete registry $ npm config delete disturl ","date":"2020-03-01","objectID":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/:3:0","tags":["NodeJS","npm"],"title":"CentOS7.x重装配置NodeJS和npm","uri":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/"},{"categories":["技术","NodeJS"],"content":"查看npm安装目录 $ npm root -g ","date":"2020-03-01","objectID":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/:4:0","tags":["NodeJS","npm"],"title":"CentOS7.x重装配置NodeJS和npm","uri":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/"},{"categories":["技术","NodeJS"],"content":"查看 npm 的 prefix 和 cache 路径配置信息 $ npm config get prefix $ npm config get cache 参考链接 利用npm安装/删除/发布/更新/撤销发布包 nodejs npm 卸载 + 重新安装 在centos7安装nodejs并升级nodejs到最新版本 阿里云CentOS7.x安装nodejs及pm2 设置Nodejs NPM全局路径 ","date":"2020-03-01","objectID":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/:5:0","tags":["NodeJS","npm"],"title":"CentOS7.x重装配置NodeJS和npm","uri":"/centos7-x%E9%87%8D%E8%A3%85%E9%85%8D%E7%BD%AEnodejs%E5%92%8Cnpm/"},{"categories":["技术","Manjaro"],"content":"系统软件全局升级，导致Jetbrain的idea也升级到了2019.3.3版本，之前的3.2版本的破解失效了，新的版本暂时找不到方法破解，在AUR上也找不到旧的软件包安装。后面发现可以利用AUR上的脚本文件构建旧版本的软件包进行安装。 降级安装包获取与安装 进入AUR,搜索相应的程序，然后点击查看PKGBUILD,如下图: 然后在界面里点击summary，然后选择相应的版本，点击提交信息里的链接，如下图: 选择下载.tar.gz结尾的文件,如下图： 解压tar.gz文件，例如: $ tar -zxvf aur-91541a618f991dde764187fab6ccf3f20805d1f0.tar.gz 进入到解压后的文件夹中,执行安装,需要注意,这里执行makepkg的时候不允许用root用户了,必须用普通用户 $ makepkg -s #-s参数可以自动解决依赖 编译完成后会生成一个.pkg.tar.xz的文件,再用pacman -U执行本地安装 $ pacman -U intellij-idea-ultimate-edition-jre-2019.3.2-1-x86_64.pkg.tar.xz pacman包管理器的设置 pacman 的配置文件位于/etc/pacman.conf。 man pacman.conf 可以查看配置文件的进一步信息。 为了避免上述的事故，可以在pacman中配置不升级的软件包。 ","date":"2020-03-01","objectID":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/:0:0","tags":["AUR"],"title":"Manjaro利用AUR装降级软件包","uri":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/"},{"categories":["技术","Manjaro"],"content":"不升级软件包 如果由于某种原因，用户不希望升级某个软件包，可以加入内容如下： IgnorePkg = 软件包名 多软件包可以用空格隔开，也可是用 glob 模式。如果只打算忽略一次升级，可以使用 --ignore 选项。忽略了的软件包可通过 pacman -S 升级。 ","date":"2020-03-01","objectID":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/:1:0","tags":["AUR"],"title":"Manjaro利用AUR装降级软件包","uri":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/"},{"categories":["技术","Manjaro"],"content":"不升级软件包组 和软件包一样，也可以不升级某个软件包组： IgnoreGroup = gnome 例如这里我就配置了idea不更新： IgnorePkg = intellij-idea-ultimate-edition ","date":"2020-03-01","objectID":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/:2:0","tags":["AUR"],"title":"Manjaro利用AUR装降级软件包","uri":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/"},{"categories":["技术","Manjaro"],"content":"升级前对比版本 要查看旧版和新版的有效安装包，请取消/etc/pacman.conf中\"VerbosePkgLists\"的注释。修改后的pacman -Syu输出如下： Package (6) Old Version New Version Net Change Download Size extra/libmariadbclient 10.1.9-4 10.1.10-1 0.03 MiB 4.35 MiB extra/libpng 1.6.19-1 1.6.20-1 0.00 MiB 0.23 MiB extra/mariadb 10.1.9-4 10.1.10-1 0.26 MiB 13.80 MiB ","date":"2020-03-01","objectID":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/:3:0","tags":["AUR"],"title":"Manjaro利用AUR装降级软件包","uri":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/"},{"categories":["技术","Manjaro"],"content":"彩色输出 Pacman 具有颜色选项，取消 “Color” 行的注释即可。 利用downgrade程序降级软件包 在终端中使用以下命令安装 “Downgrade” 实用程序： $ sudo pacman -S downgrade “downgrade” 命令的典型用法是： $ sudo downgrade [PACKAGE, ...] [-- [PACMAN OPTIONS]] 让我们假设你想要将 chrome web 浏览器 降级到任何可用的旧版本。 sudo downgrade google-chrome 示例输出: Downgrading from A.L.A. is disabled on the stable branch. To override this behavior, set DOWNGRADE_FROM_ALA to 1 . See https://wiki.manjaro.org/index.php?title=Using_Downgrade for more details. 可选的包： - 1) google-chrome 80.0.3987.149 1 x86_64 (本地) - 2) google-chrome 80.0.3987.162 1 x86_64 (本地) - 3) google-chrome 80.0.3987.163 1 x86_64 (本地) - 4) google-chrome 81.0.4044.92 1 x86_64 (本地) - 5) google-chrome 81.0.4044.113 1 x86_64 (本地) - 6) google-chrome 81.0.4044.122 1 x86_64 (本地) + 7) google-chrome 81.0.4044.129 1 x86_64 (本地) 输入数字以选择包： 参考链接 pacman AUR 入门 manjaro在Arch Linux中安装一个软件包 manjaro pacman软件包管理器常用命令 ","date":"2020-03-01","objectID":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/:4:0","tags":["AUR"],"title":"Manjaro利用AUR装降级软件包","uri":"/manjaro%E5%88%A9%E7%94%A8aur%E8%A3%85%E9%99%8D%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85/"},{"categories":["技术","VPS"],"content":"最近发现在用的Vultr的VPS网络不太稳定，查了几篇评测文章，最后决定试试HostWinds，买了半年的最基础的那个4点多刀的VPS。用起来发现确实是相对比较稳定，速度嘛，没有网上评测的那么夸张，貌似是HostWinds的线路对国内联通的比较友好，我家里是电信的网。后面有机会再试试搬瓦工的CN2 GIA-E 限量版的机型，貌似线路更好点。CN2的最便宜只有49.99美元年付，暂时不想一次买那么久。 进入正题,这次在用HostWinds的时候，一上来就连接不上VPS，用ping.pe测试国外都通，国内全红“表示被封”,显然给的ip被墙了。之前是看到HostWinds现在是可以免费换ip才买的，就刚好试试看。 点击这个按钮就可以免费更换IP: 然而我这边一开始弹出来的是显示要付费3美元更换IP，后面是根据下面的排查才解决的。 这个按钮是专门针对中国用户设计的，其他国家和地区是没有这个按钮，所以系统会判断你是否是中国用户，判断的标准有2个： 当前你是否使用的是中国IP来访问Hostwinds的官方网站 你用户资料中的国家是否是选择的中国 只要针对这两个问题一一排查就可以解决了。 你必须要用中国IP，当前不要用翻墙工具上网，这点关闭相应的工具就可以了。（不然购买服务器时付费方式那里也不会显示支付宝的选项） 需要登录Hostwinds网站后台，查看你的资料信息中的国家一栏是否选择的中国，资料信息地址：https://clients.hostwinds.com/clientarea.php?action=details ，查看如下图所示地方是否选择中国： 只要完成了相关操作就会出现“Fix ISP Block”这个免费换IP按钮了，如果没有出现就退出账号，重新登录试一下或者换个浏览器，再没有就寻求在线客服帮助一下，注意千万别去点旁边那个\"Change Main IP\"按钮，那个是给中国之外的用户使用的，需要3美元的。 根据上面那样操作后，点击Fix ISP Block按钮，等待一下，然后刷新，一个新的IP分配完成。此方法更换的IP不保证百分百可用，这也要看人品的。国内可以使用了。这个时候再去ping，发现还是不行。这个时候可以试试重装系统和重启网络系统的方法。 打开官网进入个人中心如下图所示：https://www.hostwinds.com 点击管理服务器，如下图所示： 然后进入云管理面板，如下图所示： 然后进入选择选项即可（如下图所示），一般重新生成网络就可以解决连不上问题，不行的话就重装系统重新搭建下就可以。 重装系统后需要等个五六分钟，然后在测试下，如果还是全部不通，就再次重装，有时候重装好几次才能装成功，因为最便宜的机器，内存小，装系统的容错率高。 参考链接 2020年搬瓦工、Vultr、DigitalOcean等国外VPS怎么样？谈谈怎样选择VPS云服务商 Vultr、Linode、搬瓦工、DigitalOcean 和 Hostwinds 5家国外VPS主机速度对比 美国 VPS Hostwinds 购买流程新手教程 重启Hostwinds的VPS重新生成网络和重装系统的方法 Hostwinds：免费换IP，找不到Fix ISP Block按钮的解决办法 ","date":"2020-03-01","objectID":"/hostwinds%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/:0:0","tags":["VPS"],"title":"HostWinds踩坑记录","uri":"/hostwinds%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"categories":["科学上网","V2Ray"],"content":"因为之前用的Vultr的VPS网络经常不太稳定，昨天换了HostWinds家的VPS,所以要从头配置起V2Ray,顺便记录一下，方便日后再换VPS用。 安装Dokcer 使用root账户登录，把yum包更新到最新 $ yum update （期间要选择确认，输入 y 即可） 2. 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 $ yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源（选择其中一个） $ yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo #(中央仓库） $ yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #(阿里仓库） 可以查看所有仓库中所有docker版本，并选择特定版本安装 $ yum list docker-ce --showduplicates | sort -r 安装Docker，命令：yum install docker-ce-版本号，我选的是docker-ce-18.06.3.ce，如下: $ yum install docker-ce-18.06.3.ce （期间要选择确认，输入 y 即可） 6. 启动Docker，命令：systemctl start docker，然后加入开机启动，如下: $ systemctl start docker $ systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. Docker安装V2Ray 拉取V2Ray镜像 $ docker pull v2ray/official 新建空白配置文件 $ mkdir -p /etc/v2ray $ touch /etc/v2ray/config.json $ chmod -R 777 /etc/v2ray/ 修改配置文件，参考下面代码进行修改 { \"inbounds\": [ { \"port\": 10023, // 服务器监听端口 \"protocol\": \"vmess\", // 主传入协议 \"settings\": { \"clients\": [ { \"id\": \"22ed157d-ad58-4789-adf3-c0d097c98635\", // 用户 ID，客户端与服务器必须相同 \"alterId\": 64 } ] } } ], \"outbounds\": [ { \"protocol\": \"freedom\", // 主传出协议 \"settings\": {} } ] } 修改说明： 端口数字 10023 改成你想要设定的，范围 1到65000 ； ID ：22ed157d-ad58-4789-adf3-c0d097c98635 也要更改，打开网站生成。 4. 启动V2Ray容器 $ docker run -d --name v2ray -v /etc/v2ray:/etc/v2ray -p 10023:10023 v2ray/official v2ray -config=/etc/v2ray/config.json （说明：修改两个10023为上面你改的端口） **注意:**如果有提示“IPv4 forwarding is disabled. Networking will not work”，解决方法如下： 修改/etc/sysctl.conf文件，添加如下内容： net.ipv4.ip_forward=1 然后重启网络： $ systemctl restart network 查看是否添加成功： $ sysctl net.ipv4.ip_forward 输出为1时则证明是成功的，之后创建镜像和端口转发都没有问题了。 配置BBR加速 ","date":"2020-03-01","objectID":"/centos7%E4%B8%8Adocker%E9%83%A8%E7%BD%B2v2ray/:0:0","tags":["V2Ray"],"title":"CentOS7上Docker部署V2Ray","uri":"/centos7%E4%B8%8Adocker%E9%83%A8%E7%BD%B2v2ray/"},{"categories":["科学上网","V2Ray"],"content":"什么是BBR： TCP BBR是谷歌出品的TCP拥塞控制算法。BBR目的是要尽量跑满带宽，并且尽量不要有排队的情况。BBR可以起到单边加速TCP连接的效果。 Google提交到Linux主线并发表在ACM queue期刊上的TCP-BBR拥塞控制算法。继承了Google“先在生产环境上部署，再开源和发论文”的研究传统。 TCP-BBR已经在YouTube服务器和Google跨数据中心的内部广域网(B4)上部署。由此可见出该算法的前途。TCP-BBR的目标就是最大化利用网络上瓶颈链路的带宽。一条网络链路就像一条水管，要想最大化利用这条水管，最好的办法就是给这跟水管灌满水。 BBR解决了两个问题： 在有一定丢包率的网络链路上充分利用带宽。非常适合高延迟，高带宽的网络链路。 降低网络链路上的buffer占用率，从而降低延迟。非常适合慢速接入网络的用户。 Google 在 2016年9月份开源了他们的优化网络拥堵算法BBR，最新版本的 Linux内核(4.9-rc8)中已经集成了该算法。对于TCP单边加速，并非所有人都很熟悉，不过有另外一个大名鼎鼎的商业软件“锐速”，相信很多人都清楚。特别是对于使用国外服务器或者VPS的人来说，效果更佳。BBR项目 ","date":"2020-03-01","objectID":"/centos7%E4%B8%8Adocker%E9%83%A8%E7%BD%B2v2ray/:1:0","tags":["V2Ray"],"title":"CentOS7上Docker部署V2Ray","uri":"/centos7%E4%B8%8Adocker%E9%83%A8%E7%BD%B2v2ray/"},{"categories":["科学上网","V2Ray"],"content":"安装BBR yum更新系统版本： $ yum update 查看系统版本： $ cat /etc/redhat-release 安装elrepo并升级内核： $ rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org $ rpm -Uvh https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm $ yum --enablerepo=elrepo-kernel install kernel-ml -y 更新grub文件并重启系统： $ uname -r #查看当前内核版本 $ egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \\' #查看已经安装的内核版本 $ grub2-set-default 0 #修改内核 $ reboot #重启 重启后卸载其他内核 yum -y remove kernel kernel-tools 查看内核是否已更换： $ uname -r 开启bbr $ vim /etc/sysctl.conf 在文件末尾添加如下内容 net.core.default_qdisc = fq net.ipv4.tcp_congestion_control = bbr 加载系统参数 $ sysctl -p 输出了我们添加的那两行配置代表正常。 8. 确定bbr已经成功开启： $ sysctl net.ipv4.tcp_available_congestion_control net.ipv4.tcp_available_congestion_control = reno cubic bbr $ lsmod | grep bbr tcp_bbr 20480 8 输出内容如上，则表示BBR已经成功开启。 参考链接 V2Ray 記錄 CENTOS7.6 配置BBR加速 如何在 Docker 安装 V2ray V2Ray / SSR 传输协议哪个好? (各种协议对比) ","date":"2020-03-01","objectID":"/centos7%E4%B8%8Adocker%E9%83%A8%E7%BD%B2v2ray/:2:0","tags":["V2Ray"],"title":"CentOS7上Docker部署V2Ray","uri":"/centos7%E4%B8%8Adocker%E9%83%A8%E7%BD%B2v2ray/"},{"categories":["技术","Hexo"],"content":"准备环境与安装 Node.js 下载，并安装。 安装Hexo，在命令行运行以下命令： npm install -g hexo-cli 初始化Hexo，在命令行依次运行以下命令即可： \u003cfolder\u003e即存放Hexo初始化文件的路径， 即站点目录。 hexo init \u003cfolder\u003e cd \u003cfolder\u003e npm install 新建完成后，在路径下，会产生这些文件和文件夹： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 注： 站点配置文件：站点目录下的_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml，路径为\\themes\\\u003c主题文件夹\u003e\\_config.yml\u003e。 package.json：应用程序信息 scaffold：模板文件夹，新建文章时，Hexo会根据scaffold来建立文件。 source：资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： hexo server 浏览器访问网址： http://localhost:4000/ 至此Hexo博客已经搭建在本地。 配置Hexo ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:0:0","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"配置 hexo 网站相关信息 我们在站点的配置文件_config.yml 中，修改： # Sitetitle:# 网站标题subtitle:# 网站副标题description:# 描述，介绍网站的keywords:# 网站的关键字author:# 博主姓名language:zh-CN# 语言：zh-CN 是简体中文timezone:# 时区 注意：博客框架默认的语言是英文，我们需要到 /themes/\u003c主题\u003e/languages 目录下，查看当前 主题 版本简体中文对照文件的名称是 zh-Hans 还是 zh-CN。这里NexT是 zh-CN。 ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:1:0","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"安装配置主题(以Next7为例) ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:2:0","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"获取 NexT 进入hexo主目录 $ cd hexo $ git clone https://github.com/theme-next/hexo-theme-next themes/next 更新：推荐使用独立的配置文件（数据文件）而不在主题源代码进行更改，便于后续的更新（下载最新版本，替换掉旧版本） ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:2:1","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"修改默认主题设置 $ vim _config.yml theme: next 主题目录结构 . ├── _config.yml ├── languages ├── layout ├── scripts └── source _config.yml: 主体的配置文件, 修改时会自动更新, 无需重启服务器 languages: 语言文件夹, 参见国际化 layout: 布局文件夹, 用于存放主题的模板文件, 决定网站内容的呈现方式,Hexo 内建 Swig 模板引擎, 可以另外安装插件来获得 EJS, Haml, Jade 支持, Hexo 根据模板文件的扩展名来决定所使用的模板引擎 scripts: 脚本文件夹, 在启动时, Hexo 会自定载入此文件夹内的 JavaScript 文件 source: 资源文件夹, 除了模板以外的 Asset, 如 CSS , JavaScript 文件等, 都应该放在这个文件夹中. 文件或文件夹前缀为 _ (下划线) 或 隐藏的文件会被忽略. 如果文件可以被渲染的话, 会经过解析然后存储到 public 文件夹, 否则会直接拷贝到 public 文件夹. ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:2:2","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"配置主题 配置 hexo 中的 about、tag、categories、sitemap 菜单 默认的主题配置文件_config.yml 中，菜单只开启了首页和归档，我们根据需要，可以添加 about、tag、categories 等菜单，所以把它们也取消注释。 # 菜单设置为 菜单名: /菜单目录 || 菜单图标名字menu:home:/||homeabout:/about/||usertags:/tags/||tagscategories:/categories/||tharchives:/archives/||archive 注：hexo 所有图标均来自 fontawesome，其中 || 后面是你想要设置的图标的名字。 Hexo增加 about页面 进入Hexo目录，执行hexo new page \"about\"，会发现在source目录下多了个about目录，在里面的index.md写入内容 在theme//_config.yml里面的menu一项，添加一行：about: /about/ || user。 Hexo增加tags/categories 页面 # tags $ hexo new page \"tags\" $ vim source/tags/index.md --- title: 文章标签 date: 2020-02-01 17:37:35 # 时间随意 type: \"tags\" # 类型一定要为tags comments: false # 提示这个页面不需要加载评论 --- $ vim themes/next/_config.yml menu: # ... tags: /tags/ || tags # ... # categories $ hexo new page \"categories\" $ vim source/categories/index.md --- title: 文章分类 date: 2020-02-01 17:32:39 type: \"categories\" # 类型一定要为categories comments: false --- $ vim themes/next/_config.yml menu: # ... categories: /categories/ || th # ... 配置 hexo 中 next 主题样式选择 NexT 一共提供了 4 种首页样式，按照自己喜好选择一个，选择一个其他主题样式后其他的主题前一定要加上注释#： # Schemesscheme:Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 新建一个 404 页面 首先在 hexo/source 目录下创建自己的 404.html, 注意：Hexo 博客的基本内容是一些 Markdown 文件，放在 source/_post 文件夹下，每个文件对应一篇文章。除此之外，放在 source 文件夹下的所有开头不是下划线的文件，在 hexo generate 的时候，都会被拷贝到 public 文件夹下。但是，Hexo 默认会渲染所有的 HTML 和 Markdown 文件。 因此我们可以简单地在文件开头加上 layout: false 一行来避免渲染： +layout: false +--- \u003c!DOCTYPE html\u003e 配置 hexo 站点的 footer 信息 底部 footer 可以开关显示 hexo 信息、theme 信息、建站时间以及网站备案号等个性化配置： footer:since:2018# 建站开始时间icon:name:heart# 设置 建站初始时间和至今时间中间的图标，默认是一个'小人像'，更改user为heart可以变成一个心animated:truecolor:\"#ff0000\"# 更改图标的颜色为红色 #显示版权作者copyright:JohnnyChanpowered:enable:true# 开启hexo驱动显示version:true# 开启hexo版本号theme:enable:true# 开启主题驱动version:true# 开启主题版本号beian:enable:true# 开启备案号显示icp:粤ICP备...# 备案号 设置侧栏 默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。可以通过修改主题配置文件中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 sidebar:position:rightdisplay:postonmobile:true# 移动端显示侧栏,只有设计模板为Muse或Mist才能使用 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有： left - 靠左放置 right - 靠右放置 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 头像信息设置 avatar:url:/images/avatar.jpg# 设置头像资源的位置rounded:true# 开启圆形头像rotated:true# 开启旋转 社交信息和友链配置 这里和菜单设置格式一样，社交名字: 社交url || 社交图标，图标信息来自 fontawesome： social:GitHub:https://github.com/yourname||githubE-Mail:mailto:yourname@gmail.com||envelopesocial_icons:enable:true# 显示社交图标# 仅显示图标 icons_only:true# 只显示图标，不显示文字transition:true# 动画效果 首页文章属性 post_meta:item_text:true# 可以一行显示，文章的所有属性created_at:true# 显示创建时间updated_at:enabled:true# 显示修改的时间another_day:true# 设true时，如果创建时间和修改时间一样则显示一个时间categories:true# 显示分类信息 开启文章目录 编辑主题配置文件，配置如下： toc:#侧栏中的目录enable:true#是否自动生成目录number:true#目录是否自动产生编号wrap:false#标题过长是否换行expand_all:falsemax_depth:6#最大标题深度 Follow me on GitHub 编辑主题配置文件，配置如下： # #添加右上角github绑定github_banner:enable:truepermalink:https://github.com/johnnyww?tab=repositoriestitle:FollowmeonGitHub 阅读书签 Bookmark是一个插件，允许用户保存他们的阅读进度。用户只需单击页面左上角的书签图标即可保存滚动位置。当他们下次访问您的博客时，他们可以自动恢复每个页面的最后滚动位置。 编辑主题配置文件，配置如下： bookmark:enable:truecolor:\"#222\"save:auto 字数统计、阅读时长 首先安装插件： $ npm install hexo-symbols-count-time --save 主题配置文件修改如下： symbols_count_time:separated_meta:true# 统计信息不换行显示item_text_post:true# 文章统计信息中是否显示“本文字数/阅读时长”等描述文字item_text_total:false# 底部footer站点统计信息中是否显示“本文字数/阅读时长”等描述文字awl:4# 平均字符长度wpm:275# 阅读速度, 一分钟阅读的字数 站点配置文件 新增如下： # 新增文章字数统计symbols_count_time:#文章内是否显示symbols:true# 文章字数time:true# 阅读时长# 网页底部是否显示total_symbols:false# 所有文章总字数total_time:false# 所有文章阅读中时长 显示当前浏览进度 右下角显示文章当前浏览进度，提供意见置顶功能，编辑主题配置文件，配置如下： back2top:enable:true#是否提供一键置顶 sidebar:falsescrollpercent:true# 是否显示当前阅读进度 阅读进度 Next支持页面滚动阅读进度指示器。 编辑主题配置文件，配置如下： reading_progress:enable:trueposition:topcolor:\"#37c6c0\"height:3px 图片懒加载 对于图片进行延迟加载，访问到图片位置时才去请求图片资源，这样可以提高博客的访问速度，节省流量。 命令如下： $ git clone https://github.com/theme-next/theme-next-jquery-lazyload source/lib/jquery_lazyload 编辑主题配置文件，配置如下： lazyload:true 添加图片灯箱 添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 fanc","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:2:3","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"草稿 \u0026\u0026 布局 ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:3:0","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"草稿布局 为了避免写了一半的文章发布出去，可以在新建布局的时候选择草稿：hexo new draft \"blog title\"，但是我发现生成的页面没有日期。经搜索，找到其模板位置：./hexo-folder/scaffolds/draft.md，修改为如下： --- title: {{ title }} tags: categories: description: date: {{ date }} --- 点击阅读前文前, 首页能看到的文章的简短描述 ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:3:1","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"广义布局 更广义上来说，你可以在 scaffolds 中定制任意多个布局，draft 和 page 是最常用的两个： post：在这里的会当做文章被发布。 draft：放在这里，避免写了一半的文章被发布。 page：在首页增加标签页。 为了发不同类型的文章，比如说游记、技术等等，完全可以事先创造多个布局（通过嵌入一些默认变量和 HTML 代码来实现），然后通过 hexo new layout \"title\" 来新建具有该布局的文章，当然，该文章会默认被创建在 post 文件夹中。 比如： $ cp scaffolds/page.md scaffolds/test.md $ hexo new test 'test' INFO Created: hexo/source/_posts/2019-10-16-test.md 就会创建一个具有 test 模板的文章：~/Code/blog/hexo/source/_posts/2019-10-16-test.md 如果不指定模板，会默认使用 _config.yml 中的 default_layout 参数代替，一般来说是 post。 ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:3:2","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"草稿（draft） draft 布局用于创建草稿，生成的文档存在于 source_drafts\\ 目录中，默认配置下将不会把该目录下的文档渲染到网站中。 考虑到一些文章可能需要数天才能完成，建议将新建文档时的默认布局设置为 draft： - default_layout: post + default_layout: draft 测试草稿 hexo server创建的测试网站，默认是不渲染草稿的，如果需要渲染草稿需要加上后缀hexo server –draft 通过以下命令将草稿发布为正式文章： $ hexo publish [layout] \u003cfilename\u003e 该命令会将 source_drafts\\ 目录下以的文章从 draft 移动到 post （只需要用 shell 的 mv 命令也可以)。 ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:3:3","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"标签与分类 标签和分类是什么，其区别是什么。 标签和分类都是用于对文章进行归档的一种方式，标签是一种列表结构，而分类是一种树结构。我们以人作为例子，从标签的角度考虑，我可以拥有程序员、高颜值、幽默等标签，这些标签之间没有层级关系；从分类的角度考虑，我是亚洲人、中国人、河南人，这些分类之间是有明确的包含关系的。 可以在 Front-Matter 中添加 catergories 和 tags 字段为文章添加标签和分类，如我为本文添加了 Hexo 和 Markdown 两个标签，并将其归类到了 技术 / 博客 类别，对应的 Front-Matter 结构如下： title: Hexo搭建个人博客系列：写作技巧篇 tags: Hexo Markdown categories: - 技术 - 博客 ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:4:0","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"文章标题格式 在文章顶部必须采用以下格式(称为Front-matter，是文件最上方以 -– 分隔的区域，用于指定个别文件的变量)，将xxxx替换为文章标题，否则文章标题会显示为未命名 --- title: xxxx --- 属性： title：定义了博文的标题 date：定义了创作此博文的时间 tags：定义了博文的标签 update：定义了最后修改的时间 comments：定义能否评论此博文（true/false，默认为true） categories：定义了博文的种类 ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:5:0","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"首页文章不展示全文显示摘要 在文章中加以下标签，后面的内容就不会显示出来了。 \u003c!--more--\u003e ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:6:0","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["技术","Hexo"],"content":"代码块进阶用法 可以通过为代码块附加参数的形式为其添加更丰富的信息提示，效果如下： console.log(\"Hello world!\"); 代码块进阶语法规则： ``` [language] [title] [url] [link text] code snippet ``` 其中，各参数意义如下： langugae：语言名称，引导渲染引擎正确解析并高亮显示关键字 title：代码块标题，将会显示在左上角 url：链接地址，如果没有指定 link text 则会在右上角显示 link link text：链接名称，指定 url 后有效，将会显示在右上角 url 必须为有效链接地址才会以链接的形式显示在右上角，否则将作为标题显示在左上角。以 url 为分界，左侧除了第一个单词会被解析为 language，其他所有单词都会被解析为 title，而右侧的所有单词都会被解析为 link text。 如果不想填写 title，可以在 language 和 url 之间添加至少三个空格。 参考链接 Hexo 博客 Hexo+nexT 博客建设指南 Hexo-NexT (v7.0+) 主题配置 本博客当前使用的插件总结 Hexo+NexT 搭建博客笔记 Hexo4.0+Next7.2.4主题优化配置 hexo配置NexT主题 Hexo-Next 主题下对博客进行优化 Hexo博客+Next主题深度优化与定制 Hexo 搭建个人博客系列：进阶设置篇 Hexo Next 主题进阶设置 Hexo进阶高级教程（二） Hexo + Next 主题博客提交百度谷歌收录 hexo优化之——使用gulp压缩资源 Hexo博客静态资源压缩 Hexo-NexT 主题个性优化 在不同平台安装使用 pandoc ","date":"2020-02-25","objectID":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/:7:0","tags":["Hexo安装配置","Hexo优化","NexT主题配置"],"title":"Hexo-NexT (v7.7.0) 主题安装配置优化","uri":"/hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"},{"categories":["工具","Travis"],"content":"使用Travis平台的可持续集成服务来部署自己的Hexo博客。 环境说明 Github公开项目(Travis对开源项目是免费，对私有项目是收费的) Linux服务器(这里用的阿里云的学生机，系统是CentOS 7.0) 终端连接器（用的是Manjaro终端直接连接） 自动化部署流程 本地修改代码，提交到指定分支 Travis监听仓库改变 Travis执行install和script任务（这里可以做一些安装测试构建任务的依赖和测试构建命令。） 任务执行成功后，在Travis的 after_success 钩子里面用 ssh免密登陆 服务器 自动在服务器上执行配置的脚本 Travis项目配置 在Github创建一个公有(public)仓库，然后访问官方网站travis-ci.org或者travis.com，推荐后一个，因为可以私有仓库（每个帐号一开始有100次私有仓库构建的体验服务）和公有仓库的构建都能一起管理，.org只能单看公有仓库的构建。点击右上角的个人头像，使用 Github 账户登入 Travis CI。 Travis 会列出 Github 上面你的所有仓库，以及你所属于的组织。此时，选择你需要 Travis 帮你构建的仓库，打开仓库旁边的开关。一旦激活了一个仓库，Travis 会监听这个仓库的所有变化。 假设现在已经对某个项目开启了 Travis，那么先去看看 Settings 里默认开启的那几项，根据自己实际需求进行设置，没什么特殊需求默认的设置就可以了。 创建添加 .travis.yml 到项目的根目录（稍后要提交到你关联的仓库中的）说白了接下来的事情都是如何去写这个配置文件，因为 Travis 全是根据这个配置文件去执行相应动作的。 在本地项目根目录的master分支里面添加 .travis.yml 配置文件，添加如下配置: language:node_js#前端工程所以是JavaScript，编译环境是node_jsnode_js:- 12.14.1#指定node版本branchs:only:- master#指定只有检测到master分支有变动时才执行任务 将该配置文件推送到服务器。 返回Travis网站，此时Travis已经检测到该仓库的变动（有可能会有点延迟），所以会根据仓库根目录下的.travis.yml配置文件开始执行任务。 可以在Job log界面看任务执行时的输出，在View config的标签页下面看到此次任务的配置信息，包括了你在.travis.yml里面配置的和Travis自动配置的信息。 此时，Travis监听仓库变化，自动执行任务已经完成了，也就是流程中的前三步已经完成了。 Travis使用SSH免密登陆服务器 SSH的登陆原理看这个SSH公钥登陆原理。SSH录利用的是非对称加密的方式。基本步骤就是 在客户端生成公钥和私钥 然后将私钥保存在客户端的~/.ssh/id_rsa中 将公钥保存在服务器的~/.ssh/authorized_keys文件中 更改文件的权限后，我们就能直接通过ssh免密登录我们的服务器。但是我们是无法操作travis的客户端的，但是如果我们了解ssh免密登录的原理后，你会发现公钥和私钥在什么地方生成都行，最重要的是两个要成对。 ssh免密登录的大致过程就是：客户端向服务器发起登录请求，服务器向客户端返回一段随机字符串，客户端收到这段字符串后使用自己的私钥进行加密，然后发给服务器。服务器接收后使用自己保存的公钥解密，如果解密后的数据相等就登录成功，否则断开连接。 所以，公钥和私钥的生成我们完全可以在自己的服务器上进行操作。首先，登录到自己的服务器。 ","date":"2020-02-06","objectID":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/:0:0","tags":["Travis"],"title":"使用Travis部署Hexo","uri":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/"},{"categories":["工具","Travis"],"content":"生成公钥/私钥对 这里直接在服务器上面生成密钥对，理论上在哪里生成密钥对都可以，只要是配套的。 用一个非root的常用用户或者新建一个用户，切到该用户下 # 生成RSA密钥对，后面所有的直接以默认就行，passphase一定要为空 $ ssh-keygen -t rsa 可以看到生成密钥对在用户家目录的.ssh文件夹下面。 由于Linux权限的控制规则，文件的权限不是越大越好，所有需要设置合适的权限。这里需要把.ssh目录设置为700权限（可能默认就是），目录下面的文件设置为600权限。 $ chmod 600 ~/.ssh/* 然后将生成的公钥(id_rsa.pub)中的内容添加到.ssh/authorized_keys中 $ touch ~/.ssh/authorized_keys $ cat ~/.ssh/id_rsa.pub \u003e\u003e ~/.ssh/authorized_keys 到此，密钥对已经生成完成。下面，我们就需要测试一下免密登录的操作是否能成功。在.ssh目录下执行一下操作： $ touch config 然后在config中添加如下内容: Host test # 换成需要登录的主机ip HostName $IP # 端口号 Port 6666 # 换成需要登录的用户名 User $UserName StrictHostKeyChecking no IdentitiesOnly yes # 私钥的存放路径 IdentityFile ~/.ssh/id_rsa $ ssh test 运行ssh test后报错Bad owner or permissions on ~/.ssh/config。这里同样要求我们要把.ssh/config和.ssh/authorized_keys权限设置为600。登录成功的花会有另外的信息，同时在.ssh/下多了一个known_hosts文件。 下面我们就需要将上面的密钥对中的私钥放在travis上，但是我们是无法直接操作travis服务器的，因此我们也就不能将私钥放在travis服务器上。但是，我们可以将私钥放在travis服务器能够读取的地方，因为travis是能够直接读取我们项目的工程的，所以，我们可以将私钥放在我们的项目中，travis提供了对私钥进行加密的功能，我们可以将私钥加密之后放在我们的工程中，当travis需要连接我们的服务器时，就解密这个私钥用于连接。 ","date":"2020-02-06","objectID":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/:1:0","tags":["Travis"],"title":"使用Travis部署Hexo","uri":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/"},{"categories":["工具","Travis"],"content":"安装Travis客户端 ","date":"2020-02-06","objectID":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/:2:0","tags":["Travis"],"title":"使用Travis部署Hexo","uri":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/"},{"categories":["工具","Travis"],"content":"安装ruby Travis是通过gem进行安装的，gem是ruby的管理工具，所以我们需要先安装ruby。 $ curl -sSL https://get.rvm.io | bash -s stable sudo yum install ruby #这是centos系统下安装命令 $ yum install rubygems $ yum install ruby-devel 查看RubyGems环境变量配置命令： $ which gem 正确找到会输出内容 /usr/bin/gem，如果没有找，则需要进行环境变量的设置，有则无需设置了。 ","date":"2020-02-06","objectID":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/:2:1","tags":["Travis"],"title":"使用Travis部署Hexo","uri":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/"},{"categories":["工具","Travis"],"content":"修改镜像源 安装完ruby之后就可以使用gem包管理工具了，但是好像官方镜像源被墙了，所以需要更换gem的镜像源。参考Ruby China $ gem sources -l *** CURRENT SOURCES *** https://rubygems.org/ $ gem -v 2.7.7 #更换镜像源 $ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ https://gems.ruby-china.com/ added to sources https://rubygems.org/ removed from sources $ gem sources -l *** CURRENT SOURCES *** https://gems.ruby-china.com/ ","date":"2020-02-06","objectID":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/:2:2","tags":["Travis"],"title":"使用Travis部署Hexo","uri":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/"},{"categories":["工具","Travis"],"content":"安装Travis命令行工具 $ gem install travis $ travis help #测试travis客户端是否安装成功 将项目用git克隆到服务器上，进入到项目的根目录下 $ travis login 或者运行以下其中一条命令，根据GitHub关联授权的travis网址后缀选择 $ travis login --com $ travis login --org # 加密私钥匙并把的对应信息加入到.travis.yml中 $ travis encrypt-file ~/.ssh/id_rsa --add 然后，你就会发现在项目的根目录下多了一个id_rsa.enc文件以及.travis.yml多了一个before_install指令 $ cat .travis.yml language: node_js node_js: - 12.14.1 branchs: only: - master before_install: - openssl aes-256-cbc -K $encrypted_311a3ff6a6ef_key -iv $encrypted_311a3ff6a6ef_iv -in id_rsa.enc -out ~/.ssh/id_rsa -d 解密命令中 -in 和 -out 参数: in 参数指定待解密的文件，位于仓库的根目录(Travis执行任务时会先把代码拉到Travis自己的服务器上，并进入仓库更目录) out 参数指定解密后的密钥存放在Travis服务器的~/.ssh/id_rsa,需要手动将-out选项的值多了的一个\\符号去掉 然后将变更推送到master分支，触发travis构建。 配置after_success 到此，我们就差最后一个步骤了：在.travis.yml中添加一些配置，主要是after_success钩子配置。修改之后的配置如下： language:node_jsnode_js:- 12.14.1branchs:only:- master#设定分支addons:ssh_known_hosts:- $SERVER_IP#受信主机，在使用 ssh 登陆时会确认主机信息，travis-ci 无法进行交互操作。所以需要在 .travis.yml 中添加addons:ssh_known_hostsbefore_install:- opensslaes-256-cbc-K$encrypted_311a3ff6a6ef_key-iv$encrypted_311a3ff6a6ef_iv-inid_rsa.enc-out~/.ssh/id_rsa-d- chmod600~/.ssh/id_rsa#还是Linux文件权限问题- echo-e\"Host \"$SERVER_IP\"\\n\\tStrictHostKeyChecking no\\n\"\u003e\u003e~/.ssh/configafter_success:- sshchenjunxin@\"$SERVER_IP\"-p\"$SERVER_PORT\"-oStrictHostKeyChecking=no'. /home/chenjunxin/deploy/deployhexo.sh'# - ssh chenjunxin@\"$SERVER_IP\" -o StrictHostKeyChecking=no 'cd ~/hexo \u0026\u0026 git pull \u0026\u0026 npm install \u0026\u0026 hexo clean \u0026\u0026 hexo g' ssh命令需要加上StrictHostKeyChecking=no选项，具体的可以查看禁用ssh远程主机的公钥检查。 可以直接在ssh连接后面写要运行的命令，也可以写在服务器上的shell文件里，然后远程登录执行。 after_success是在Travis执行完 install 和 script 之后执行的钩子,其他的Travis配置可以参考官方文档。 “$SERVER_IP”:这个值是Travis加密的值，可以设置在Job log中是否显示。可以在Travis控制台中的Setting中设置。 也可以在服务器上运行以下命令（$IP填具体IP的值） $ travis encrypt \"SERVER_IP=$IP\" --add 命令执行之后会在.travis.yml新增一个sercure的值。 在运行的时候，Travis那边的服务器会分别从Setting设置与.travis.yml文件获取定义的变量值。更详细的内容可以查阅官方文档 一点补充 服务器上的travis客户端的配置文件在用户目录下的$HOME/.travis/中。其中的config。yml里可以 endpoint可以配置数据库构建的地址，可以是https://api.travis-ci.com/ 或者 https://api.travis-ci.com/ 参考链接 使用Travis CI自动部署Hexo博客 travis自动化部署github项目到server Hexo + GitHub + Travis CI + VPS 自动部署 Travis CI 系列自动化部署测试教程（VPS服务器） travis自动化部署续篇 Travis-CI自动化测试并部署至自己的CentOS服务器 利用travis-ci持续部署nodejs应用 禁用SSH远程主机的公钥检查 解决linux中ssh登录Warning:Permanently added (RSA) to the list of known hosts TrueChain持续集成项目打包（Travis-CI） ","date":"2020-02-06","objectID":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/:2:3","tags":["Travis"],"title":"使用Travis部署Hexo","uri":"/%E4%BD%BF%E7%94%A8travis%E9%83%A8%E7%BD%B2hexo/"},{"categories":["技术","Manjaro"],"content":"需求:想着装好的Manjaro跟同一网络下我的windows系统的笔记本之间能共享借助网络互传些数据,顺便可以的话就让家里的小米电视播放我放在电脑上的一些媒体资源。 在这过程中，了解了些东西，顺便总结一下。 几种媒体共享方式区别 目前常见的媒体共享方式主要有以下几种：Samba、FTP、Upnp（DLNA）、NFS ","date":"2020-02-03","objectID":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/:0:0","tags":["Manjaro安装和配置","Samba","DLNA"],"title":"Manjaro搭建Samba和DLNA服务","uri":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/"},{"categories":["技术","Manjaro"],"content":"Samba Windows用户都知道的共享方式，局域网访问方便，一般不用于外网访问。 特点是设置方便，缺点是传输效率低，速度不稳定，会有波动。(我一开始就是搭了这个，后面电视访问电脑看视频的时候，经常不太稳定，才开始找别的方案的。) 所以，Samba已经不是最佳的家庭媒体共享方式。 ","date":"2020-02-03","objectID":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/:1:0","tags":["Manjaro安装和配置","Samba","DLNA"],"title":"Manjaro搭建Samba和DLNA服务","uri":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/"},{"categories":["技术","Manjaro"],"content":"FTP FTP其实还分为SFTP,FTPS，FTP还支持TLS，这些都是在安全方面的增强。因为FTP是明文密码。 FTP的优势是只要通讯端口开启，IP没错，都能方便连接上，而且特别适合外网共享。 FTP主要用于客户端和服务器之间的文件上传和下载。不适用于修改服务器上的文件。因为它要存取一个文件，就必须先获得一个本地文件的副本，如果修改文件，也只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。所以如果你要修改服务器上的一个超大文件，但是只修改几个字节的内容。你依然需要下载整个文件过来，修改完毕后，再回传回去。 FTP的速度非常一般，不推荐用来作为家庭媒体服务器的局域网播放方式。 ","date":"2020-02-03","objectID":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/:2:0","tags":["Manjaro安装和配置","Samba","DLNA"],"title":"Manjaro搭建Samba和DLNA服务","uri":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/"},{"categories":["技术","Manjaro"],"content":"Upnp（DLNA） 要求设备必须是处于同一网段内，共享服务的设置也比较简单。由于是专门用于局域网媒体播放的协议，所以网络传输效率也很高，超大文件的快进，后退，都很流畅。唯一的缺点是不支持外挂字幕。 另外Upnp（DLNA）的解码是服务器端实现的。所以大幅消耗的是路由器或NAS的硬件资源，而不是播放设备的硬件资源。如果路由器硬件不够强悍，可能会导致其他用户上网受影响。 ","date":"2020-02-03","objectID":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/:3:0","tags":["Manjaro安装和配置","Samba","DLNA"],"title":"Manjaro搭建Samba和DLNA服务","uri":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/"},{"categories":["技术","Manjaro"],"content":"NFS 允许应用进程打开一个远地文件，并能够在该文件中某一个特定位置上开始读写数据。本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。所以NFS修改服务器上的文件时，可使用户只复制一个大文件中的一个很小的片段，在网络上传送的只是少量的修改数据。 NFS的网络利用率也非常高，速度很快。相比Upnp（DLNA），NFS还支持视频外挂字幕。只要将同名的字幕文件放在同一个目录下即可。 我开启的是Samba和DLNA服务(NFS试过，没成功，客户端能扫描到我的目录一直扫描不到里面的资源，各种方法试过了，加上暂时没有需要外挂字幕的资源，就先不搞了。) Samba和DLNA安装 ","date":"2020-02-03","objectID":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/:4:0","tags":["Manjaro安装和配置","Samba","DLNA"],"title":"Manjaro搭建Samba和DLNA服务","uri":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/"},{"categories":["技术","Manjaro"],"content":"Samba服务器安装 sudo pacman -S samba nautilus-share manjaro-settings-samba 配置/etc/samba/smb.conf参数 安装上面软件之后，开始配置参数，先备份smb.conf $ mv /etc/samba/smb.conf /etc/samba/smb.conf.bak 然后新建一个，写入如下参数 vim /etc/samba/smb.conf [global] #所要加入的工作组或者域 workgroup = WORKGROUP #用于在 Windows 网上邻居上显示的主机名 netbios name = Manjaro #定义安全级别 security = user #将所有samba系统主机所不能正确识别的用户都映射成guest用户 map to guest = bad user #是否开启dns代理服务 dns proxy = no #[]内是共享显示的目录名 [media] #实际共享路径 path = /home/johnnychan/code #共享的目录是否让所有人可见 browsable = yes #是否可写 writable = yes #是否允许匿名(guest)访问,等同于public guest ok = yes #客户端上传文件的默认权限 create mask = 0777 #客户端创建目录的默认权限 directory mask = 0777 #注意共享文件在系统本地的权限不能低于以上设置的共享权限。 修改好了输入 $ testparm /etc/samba/smb.conf 检查是否有语法错误,接着配置权限和密码工作 #将系统用户加入到samba用户，并设置密码，这里我们按两次回车，设置成无密码 $ smbpasswd -a johnnychan #这里johnnychan是自己系统用户名 $ pdbedit -L #查看所有Samba用户 $ smbclient -L 127.0.0.1 #查看对应IP上的samba服务器,例如这里查看本机 chmod 777 /home/johnnychan/code -R #将 path 中目录的权限设置为777 chmod 777 /home/johnnychan/ #这个不给权限会拒绝访问 然后启动服务 systemctl start smb #启动服务 systemctl enable smb #开机自启 #其他命令 systemctl status smb #查询状态 systemctl restart smb #重新启动 Manjaro防火墙默认关闭的，并且没有安装selinux，安装了的需要关闭 systemctl stop iptables #关闭防火墙 setenforce 0 #关闭selinux sudo vim /etc/selinux/config #关闭selinux开机启动 将SELINUX=enforcing改为SELINUX=disabled ","date":"2020-02-03","objectID":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/:5:0","tags":["Manjaro安装和配置","Samba","DLNA"],"title":"Manjaro搭建Samba和DLNA服务","uri":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/"},{"categories":["技术","Manjaro"],"content":"DLNA分享服务安装 首先是安裝 DLNA server，使用的是 minidlna 这个软件。 sudo pacman -S minidlna 接着编辑/etc/minidlna.conf 来设定分享目录: media_dir=/srv/media 第一行会把 /srv/media 底下所有的媒体文件(照片，影片，音乐)分享出去. 如果想要限制媒体的种类, 可以在目录前加上 V(影片), A(声音)或 P(照片)来指定种类: media_dir=V,/home/johnnychan/dlna/dlna_videos media_dir=P,/home/johnnychan/dlna/dlna_pictures 还有修改如下的配置: #web端口，可以通过ip:port查看索引状态 port=8200 #服务器命名 friendly_name=Raspi_DLNA #miniDLNA启动的时候，默认用户是minidlna，修改为root，避免后续文件访问的权限问题。 user=root #开启自动更新媒体库 inotify=yes systemctl start minidlna #启动服务 systemctl force-reload minidlna # 强制刷新DLNA cache ps -aux|grep minidlna #查看服务是否已经运行 systemctl status minidlna # 查看服务状态 systemctl enable minidlna # MiniDLNA随机启动 访问界面http://127.0.0.1:8200/ 可以查看索引状态 这么一来, 支持 DLNA 的播放程序如VLC 就可以直接浏览 server 上的媒体, 并且串流播放. 当然, 平板或手机也能轻易播放分享出来的媒体，DLNA支持的媒体格式挺丰富的。 如果想进一步对某些内容进行设置授权才能够查看的话，可以使用一个利用 MAC address 来过滤封包的程序(ebtables)。 参考链接 Manjaro搭建无密访问samba服务器 MiniDLNA 1.2.1 中文配置 在 Linux 上設定 DLNA 分享服務 MiniDLNA文件共享 DLNA分享服务设置(Linux minidlna版) MiniDLNA的视频文件夹权限问题 ","date":"2020-02-03","objectID":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/:6:0","tags":["Manjaro安装和配置","Samba","DLNA"],"title":"Manjaro搭建Samba和DLNA服务","uri":"/manjaro%E6%90%AD%E5%BB%BAsamba%E5%92%8Cdlna%E6%9C%8D%E5%8A%A1/"},{"categories":["技术","Manjaro"],"content":"在Windows系统上进行分区 进入windows磁盘管理器，分别新建两个简单卷，只设置大小，不需要格式化。一个设置为600M大小用于挂载efi,另一个用于挂载根目录/,大小随意。(我是在一块500g的固态上分出一半来装的，需要注意的是如果重新装系统的时候,挂在efi那个分区不能直接格式化删除，不然后面再分成一样大小的还是挂载efi会报错，没搞懂什么问题，一开始分的1g,后面直接格式化了，一直分1g一直报错，就分了600M装，才莫名成功了，本来都想装虚拟机算了。) 制作Manjaro镜像 直接官网下的kde镜像，此次使用的是KDE Plasma 18.1.5版本， 然后用刻录工具刻录到u盘上，这次使用的是usbwrite ,也可以使用rufus。 Manjaro系统安装 ","date":"2020-01-31","objectID":"/manjaro/:0:0","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"BIOS的设置关闭掉Secure Boot 关闭掉Secure Boot 硬盘模式设置为ahci（根据机型貌似有些不用设置） 引导模式使用uefi（据说双系统win是mbr则manjaro也使用mbr比较好，我的是GPT） ","date":"2020-01-31","objectID":"/manjaro/:1:0","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"进入安装界面进行安装进入U盘之后首先回车选择最后一个是简体中文 进入U盘之后首先回车选择最后一个是简体中文 driver 因为是n卡就选择no free，其他情况选free或网上查bios选项等配置 然后回车 Boot:Manjaro.x86_64 kde 进入安装安装界面之后点击launch installr 地区选择Asia 区域选择Shanghai 分区,双系统有两种情况 ","date":"2020-01-31","objectID":"/manjaro/:2:0","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"mbr启动 这里我们直接划分出来一块分区文件系统选择ext4，挂载点 / ","date":"2020-01-31","objectID":"/manjaro/:2:1","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"uefi启动模式 这里需要一个esp分区 划出600MB分区，文件系统fat16或fat32，挂载点boot/efi，标记boot，esp 还需要一个根分区也就是系统分区 划出分区，文件系统ext4，挂载点 / ，无需标记 可以进行安装了。(/home,/swap都不用管，要是只有8g内存可以考虑配置/swap，挂载点选linuxswap就行) 安装完后点击重启计算机，在完全关闭后拔出u盘。开机后进入bios选择Manjaro引导到第一位，保存进入系统。 系统设置和软件安装 ","date":"2020-01-31","objectID":"/manjaro/:2:2","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"系统设置 进行软件源设置以及系统更新首先，我们先把它打开文件的方式改为双击 首先，我们先把它打开文件的方式改为双击 系统设置-\u003e桌面行为-\u003e工作空间-\u003e双击打开文件和文件夹 更换中国源 sudo pacman-mirrors -i -c China -m rank 在第命令结束的时候会弹出一个窗口让你选择想要使用的源，选最快的那个就行了。(例如:https://mirrors.ustc.edu.cn/manjaro/ 中科大的) 或者直接编辑文件添加源地址: sudo nano /etc/pacman.d/mirrorlist 地址从这获取,添加到文件末尾,例如: ## SJTUG 软件源镜像服务 Server = https://mirrors.sjtug.sjtu.edu.cn/manjaro/stable/$repo/$arch ## 清华大学镜像源 Server = https://mirrors.tuna.tsinghua.edu.cn/manjaro/stable/$repo/$arch 保存设置方法：用nanoc编辑好文本后按crl + x 然后按y再按回车即可。另外manjaro中的pacman相当于centos（或redhat）中的yum命令 然后更新一下数据源 ## 更新源列表 sudo pacman-mirrors -g 接着更换增加archlinuxcn软件仓库源: sudo nano /etc/pacman.conf 在最下方添加： #添加archlinuxcn软件源： [archlinuxcn] SigLevel = Optional TrustedOnly #SJTUG 软件源 Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux-cn/$arch #清华源 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch [antergos] SigLevel = TrustAll Server = https://mirrors.tuna.tsinghua.edu.cn/antergos/$repo/$arch [arch4edu] SigLevel = TrustAll Server = https://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch 然后运行两条命令: sduo pacman -Syy # -Syy表示将本地的软件与软件仓库进行同步 sudo pacman -S archlinuxcn-keyring #-S表示安装某一软件 安装archlinuxcn签名钥匙 sudo pacman -S antergos-keyring 之后更新一下系统: sudo pacman -Syu #可以更新系统的一切软件包 更新完后安装下系统缺少的字体解决中文乱码问题: sudo pacman -S wqy-microhei ","date":"2020-01-31","objectID":"/manjaro/:3:0","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"软件安装 ","date":"2020-01-31","objectID":"/manjaro/:4:0","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"安装AUR管理工具: 想要使用AUR中的软件，一种方式是在图形的软件安装界面的设置中把AUR打开，然后搜索进行安装，另外是使用命令行工具进行安装。由于Yaourt已经不再维护，这里选择了Yay来管理AUR仓库中的软件。 sudo pacman -S yay Yay默认使用法国的aur.archlinux.org作为AUR源，可以更改为国内清华大学提供的镜像。 yay 用户执行以下命令修改aururl: $ yay --aururl \"https://aur.tuna.tsinghua.edu.cn\" --save 修改的配置文件位于 ~/.config/yay/config.json 去掉 # AURURL 的注释，修改为 AURURL=\"https://aur.tuna.tsinghua.edu.cn\" yay 安装命令不需要加 sudo,yay的命令参数跟pacman参数基本一致,还可通过以下命令查看修改过的配置: $ yay -P -g yay 的常用命令： $ yay -S package # 从 AUR 安装软件包 $ yay -Rns package # 删除包 $ yay -Syu # 升级所有已安装的包 $ yay -Ps # 打印系统统计信息 $ yay -Qi package # 检查安装的版本 ","date":"2020-01-31","objectID":"/manjaro/:4:1","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"安装中文字体: sudo pacman -S wqy-zenhei sudo pacman -S wqy-bitmapfont sudo pacman -S wqy-microhei #Manjaro自带了思源系列字体（Noto家族）,补个Emoji： yay -S noto-fonts-emoji sudo pacman -S adobe-source-han-sans-cn-fonts sudo pacman -S adobe-source-han-serif-cn-fonts linux字体推荐(可选) 中文字体推荐使用：文泉驿、思源字体。安装如下： $ sudo pacman -S wqy-microhei wqy-bitmapfont wqy-zenhei wqy-microhei-lite $ sudo pacman -S adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts 西文字体推荐使用dejavu、noto字体。 $ sudo pacman -S ttf-dejavu $ sudo pacman -S noto-fonts noto-fonts-extra noto-fonts-emoji noto-fonts-cjk 优化–\u003e字体–\u003e缩放字体–\u003e1.25 字体我用的是思源黑体（adobe家开源的），文泉驿和google家的noto系列也不错。 noto系列cjk指的是中国韩国和日本，中国大陆好像是S开头的字体，因为太大了就没有安装。 chrome等其他浏览器可以在浏览器设置里改一下字体风格，然后在/etc/fonts/新建一个local.conf文件写入： \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE fontconfig SYSTEM \"fonts.dtd\"\u003e \u003cfontconfig\u003e \u003cmatch target=\"font\"\u003e \u003cedit name=\"autohint\" mode=\"assign\"\u003e \u003cbool\u003efalse\u003c/bool\u003e \u003c/edit\u003e \u003cedit name=\"hinting\" mode=\"assign\"\u003e \u003cbool\u003efalse\u003c/bool\u003e \u003c/edit\u003e \u003cedit name=\"hintstyle\" mode=\"assign\"\u003e \u003cconst\u003enone\u003c/const\u003e \u003c/edit\u003e \u003c/match\u003e \u003c/fontconfig\u003e 这样软件默认就不会用自己的文字处理方式了，和win下字体基本无太大差别，字体模糊问题解决。 ","date":"2020-01-31","objectID":"/manjaro/:4:2","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"中文输入法安装: fcitx和ibus都可以配置中文输入法 fcitx 或 ibus 两个选其一 推荐fcitx(一开始装了ibus，后面转了fcitx) fcitx5对比fcitx4 fcitx5的输入体验的确比上个版本好一些，输入相对来说比较流畅，输入中文分号不需要空格，而是按两下分号键。 自动DPI功能还需要优化。 fcitx4安装 1. 安装安装输入法模块: ```bash sudo pacman -S fcitx-im #安装全部输入法模块 #终端出现以下提示: $ yay -S fcitx-im :: There are 4 members in group fcitx-im: :: Repository community 1) fcitx 2) fcitx-gtk2 3) fcitx-gtk3 4) fcitx-qt5 Enter a selection (default=all): #直接按回车，默认4个都安装，不然后面在有些应用或者终端调不出输入法 ``` 2020-05-06更新： 现在网络上大部分老教程还是安装fcitx,fcitx-gtk2,fcitx-gtk3,fcitx-qt4,fcitx-qt5,fcitx-configtool的传统方法，目前在Archlinux的源中，fcitx-im包组已经取消了fcitx-qt4包，但是搜狗输入法Linux版是基于QT4的，少了这个包，搜狗输入法就无法正常启动。这里安装也是担心后面有些应用或者终端不支持QT5调不出输入法。 首先，如果以前安装了fcitx，全部删除： $ sudo pacman -Rsn fcitx-im fcitx-configtool 然后安装fcitx-lilydjwg-git这个包，fcitx-lilydjwg-git这个包用来替换fcitx-im包组中除fcitx-qt5之外的所有包，其中包含了fcitx-qt4包。 sudo pacman -S fcitx-lilydjwg-git 安装中文输入法选其一（我选的sunpinyin，rime和goolepinyin据说不支持模糊音） sudo pacman -S fcitx-sunpinyin sudo pacman -S fcitx-rime sudo pacman -S fcitx-libpinyin sudo pacman -S fcitx-googlepinyin 安装云拼音（可选） $ sudo pacman -S fcitx-cloudyinpin 安装fcitx-cloudpinyin后，googlepinyin，fcitx自带的pinyin，sunpinyin的候选次列表都会具有云辅助，更加智能。（rime不支持） 安装后重启 Fcitx 即可，所选的云拼音输入结果会自动添加到当前输入法的词库中。提醒：建议在fcitx设置里面将“云拼音来源”由Google改为“百度”，Google国内访问不是很顺畅。 启用云拼音后，从云拼音获得的候选词会默认添加到候选词列表中的第二个，显示位置可以通过云拼音的设置配置。如果云拼音的结果和本地输入法给出的结果一致，云拼音后选项会和本地产生的候选项自动合并，不会产生重复的候选项。 若安装fcitx-cloudpinyin后，在配置程序里却没有看见云拼音，记得勾上“高级”复选框。这时云拼音会显示出来，再勾上云拼音。 注意: 不推荐将云拼音候选词设为第一个候选词，因为当网络情况不好，没有及时返回云拼音结果，那么云拼音结果将默认降到第二候选词的位置，于是这个过程可能会涉及到默认候选词的改变。 到这里，Manjaro下的中文输入法基本就安装好了，但是还没有安装fcitx图形设置界面，另外少了个fcitx-qt5包，不能在qt5程序下输入，需要继续安装： GNOME（GTK）用户： $ sudo pacman -S fcitx-configtool fcitx-qt5 注意：fcitx-qt5可选依赖于fcitx-configtool，可以直接安装fcitx-configtool，然后选择fcitx-qt5。 KDE（QT）用户： $ sudo pacman -S kcm-fcitx 在/etc/profile或者~/.xprofile文件中，右键粘贴如下代码并保存: export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx 注销重新登录或者重启系统。 扩展点-检查设置 如果出现问题，可使用下面打命令，看下哪里配置异常，处理一下就可以了。 $ fcitx-diagnose fcitx5安装 在一些大佬的博客上看到Fcitx5，试了下发现自带的pinyin准确度确实很高，而且输入设置也整合到了设置中心，对KDE用户相当友好。fcitx的官方Repo在GitHub 安装 #卸载fcitx4 pacman -Rs $(pacman -Qsq fcitx) # 可以直接全部安装不用考虑安装顺序(archlinuxcn源) $ sudo pacman -S fcitx5-git # 安装fcitx5框架 $ sudo pacman -S fcitx5-gtk-git # 增加对gtk程序的支持 $ sudo pacman -S fcitx5-qt5-git # 增加对QT5程序的支持 $ sudo pacman -S fcitx5-qt4-git # 有QT4程序需要增加对QT4程序的支持 $ sudo pacman -S fcitx5-chinese-addons-git # 增加对中文输入的组件 $ sudo pacman -S kcm-fcitx5-git # 增加内嵌的输入设置，只限KDE # 也可以直接安装community源下的包，这里我配的是清华的镜像源，貌似没有同步好，找不到文件，所以用了上面的archlinuxcn源安装的。 $ sudo pacman -S fcitx5 fcitx5-gtk fcitx5-qt fcitx5-chinese-addons kcm-fcitx5 配置开机自启 系统设置-\u003e开机和关机-\u003e自动启动-\u003e添加程序-\u003e搜索Fcitx 选中后确定使Fcitx5自启动（推荐）。 修改配置文件 直接启动fcitx5是只有西文键盘的，如果是KDE，可以到系统的输入法配置启用拼音；如果是其他发行版，就需要使用配置文件。 首先要确认当前fcitx5是完全退出的状态，如果fcitx5在运行，修改后软件会自动覆写profile配置文件。用户配置在~/.config/fcitx5/profile [Groups/0] # Group Name Name=默认 # Layout Default Layout=us # Default Input Method DefaultIM=pinyin [Groups/0/Items/0] # Name Name=keyboard-us # Layout Layout= [Groups/0/Items/1] # Name Name=pinyin # Layout Layout= [GroupOrder] 0=默认 使用默认的pinyin就可以了。 设置环境变量 使用echo ${XDG_SESSION_TYPE}命令查看，如果是x11即xorg用户，则还应当在~/.xprofile添加如下内容： export GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=\"@im=fcitx5\" 如果是wayland用户的话，则修改~/.pam_environment文件 GTK_IM_MODULE=fcitx5 QT_IM_MODULE=fcitx5 XMODIFIERS=@im=fcitx5 注销重新登录或者重启系统就可以看到fcitx5的启动了。 个性化设置 注意修改配置文件要先彻底关闭fcitx5 关闭云拼音 如果注重个人隐私的话，建议关闭该选项。修改~/.config/fcitx5/conf/pinyin.conf： # Enable Cloud Pinyin -CloudPinyinEnabled=True +CloudPinyinEnabled=False 关闭自动API fcitx5会自动根据多显示器不同的DPI来调整界面大小，但发现经常达不到想要的效果，只好将这一功能关闭，并调整字体大小为14。修改~/.config/fcitx5/conf/classicui.conf # 按屏幕 DPI 使用 PerScreenDPI=False # Font (设置成你喜欢的字体) Font=\"Noto Sans Mono Regular 14\" 使用皮肤 使用了hosxy的Material-color皮肤，安装非常方便，依照Readme操作即可。效果惊艳，堪比Windows10自带输入法。 直接运行命令安装： $ pacman -S fcitx5-material-color 使用单行模式(inline_preedit) 对于fcitx5自带pinyin 请修改 ~/.config/fcitx5/conf/pinyin.conf # 可用时在应用程序中显示预编辑文本 -PreeditInApplicaation=False +PreeditInApplicaation=True ibus安装 sudo pacman -S ibus #安装","date":"2020-01-31","objectID":"/manjaro/:4:3","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"更改项目文件英文名 修改目录映射文件名: sudo nano .config/user-dirs.dirs 修改为以下内容: XDG_DESKTOP_DIR=\"$HOME/Desktop\" XDG_DOWNLOAD_DIR=\"$HOME/Download\" XDG_TEMPLATES_DIR=\"$HOME/Templates\" XDG_PUBLICSHARE_DIR=\"$HOME/Public\" XDG_DOCUMENTS_DIR=\"$HOME/Documents\" XDG_MUSIC_DIR=\"$HOME/Music\" XDG_PICTURES_DIR=\"$HOME/Pictures\" XDG_VIDEOS_DIR=\"$HOME/Videos\" 将Home目录下的中文目录名改为对应的英文名: mv 桌面 to Desktop mv 下载 to Downloads mv 模板 to Templates mv 公共 to Public mv 文档 to Documents mv 音乐 to Music mv 图片 to Pictures mv 视频 to Videos 重启系统 ","date":"2020-01-31","objectID":"/manjaro/:4:4","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"常用软件安装 支持复杂运算的计算器 $ sudo pacman -S speedcrunch 有些运算我们需注意单位问题，如角度单位（弧度、度数），默认它是弧度，所以你运算sin(30)不会等于0.5，在设置中或使用快捷键切换即可。 建议勾选 设置 - 行为 - Enable Complex Numbers，不然你可能连pi（圆周率表示）都无法使用。 解压工具安装 sudo pacman -S unrar unzip p7zip sudo pacman -S file-roller #图形化的解压软件 为知笔记 sudo pacman -S wiznote 思维导图 yay -S xmind-zen WPS及WPS需要的中文字体 sudo pacman -S wps-office yay -S wps-office-fonts wps-office-mime ttf-wps-fonts 福昕PDF阅读器 sudo pacman -S foxitreader 媒体播放器 $ sudo pacman -S vlc #一个免费且开源的跨平台媒体播放器以及框架，可以播放大多数格式的多媒体文件以及 DVS，音频 CD，VCD，以及各种流媒体协议 $ sudo pacman -S ffmpeg $ sudo pacman -S kodi # 一款获得殊荣的免费开源（GPL）软件，支持视频，音乐，图片，游戏以及更多内容的媒体中心。 跨平台音乐播放器listen1 $ yay -S listen1-desktop TeamViwer安装 直接运行命令安装的包打开并不能用，需要到官网下载包解压运行。 选择 Other systems (not officially supported)的↓ x86 64bit 下载到的是：teamviewer_15.3.2682_amd64.tar.xz 解压 两种解压方式： 右键鼠标选择解压 命令行解压tar xvf teamviewer_15.3.2682_amd64.tar.xz 运行Teamviwer 把解压出来的目录放到你想的任意目录，可以放在/opt/下，cd teamviewer进入目录里，运行./teamviewer 添加到Dash to Dock 修改安装目录下的teamviewer.desktop,修改图标文件路径 Icon=/opt/teamviewer/tv_bin/desktop/teamviewer_256.png 然后执行 $ sudo cp /opt/teamviewer/teamviewer.desktop /usr/share/applications/ ClamAV安装 sudo pacman -S clamav #Clam 防病毒软件（命令行） sudo pacman -S clamtk #Clam 防病毒软件（客户端） BleachBit安装 $ sudo pacman -S bleachbit #快速释放磁盘空间并不知疲倦地守卫你的隐私。释放缓存，删除 cookie，清除互联网浏览历史，清理临时文件，删除日志，以及更多功能... 截图软件 深度截图 $ sudo pacman -S deepin-screenshot flameshot flameshot安装 $ sudo pacman -S flameshot-git 配置flameshot截图快捷键 用KDE的桌面环境，可以配置下快捷键：系统设置—-\u003e快捷键—-\u003e自定义快捷键： 编辑—-\u003e新建—\u003e全局快捷键—\u003e命令/URL: 动作填入为 flameshot gui 配置flameshot守护进程 如果想要配置一些截图选项。执行以下命令： $ flameshot config 要配置下开机启动，因为flameshot是有前后端的，守护进程要有运行才能正常截图！ 壁纸自动定时切换软件—Variety $ sudo pacman -S variety 系统状态监控 sudo pacman -S deepin-system-monitor 硬件温度监测 sudo pacman -S psensor 录屏软件 sudo pacman -S deepin-screen-recorder #录屏软件，可以录制 Gif 或者 MP4 格式 sudo pacman -Ss SimpleScreenRecorder #另外一个更强大的录屏软件 deepin系列软件必备条件 首先对于非 GNOME 桌面(KDE, XFCE等)需要安装 sudo pacman -S gnome-settings-daemon 运行/usr/lib/gsd-xsettings 系统设置-\u003e开机或关机-\u003e自动启动-\u003e添加脚本-\u003e输入/usr/lib/gsd-xsettings 深度QQ sudo pacman -S deepin.com.qq.im 深度微信 微信是自己从github上下的旧版的包2.7.188版本,并根据文档修改对应的安装配置 https://github.com/countstarlight/deepin-wine-wechat-arch 安装完后手动切换deepin-wine环境 安装 deepin-wine yay -S deepin-wine 修改 deepin-wine-wechat 的启动文件 修改如下两个文件中的 WINE_CMD 的值： /opt/deepinwine/apps/Deepin-WeChat/run.sh /opt/deepinwine/tools/run.sh -WINE_CMD=\"wine\" +WINE_CMD=\"deepin-wine\" 对于非 GNOME 桌面(KDE, XFCE等)需要安装 sudo pacman Sy gnome-settings-daemon 并在 /opt/deepinwine/apps/Deepin-WeChat/run.sh 中加入如下几行： RunApp() { + if [[ -z \"$(ps -e | grep -o gsd-xsettings)\" ]] + then + /usr/lib/gsd-xsettings \u0026 + fi if [ -d \"$WINEPREFIX\" ]; then UpdateApp else 注意：对 /opt/deepinwine/apps/Deepin-WeChat/run.sh 的修改会在 deepin-wine-wechat 更新或重装时被覆盖，可以单独拷贝一份作为启动脚本 4. 删除原先的微信目录 rm -rf ~/.deepinwine/Deepin-WeChat 修复 deepin-wine 字体渲染发虚 yay -S lib32-freetype2-infinality-ultimate 注意：切换到 deepin-wine 后，对 wine 的修改，如更改dpi，都改为对 deepin-wine 的修改 百度网盘 yay -S deepin-wine-baidupan 迅雷 yay -S deepin.com.thunderspeed Aria2 下载器，支持 HTTP(S)，FTP，SFTP，BitTorrent和Metalink 协议 安装 sudo pacman -S aria2 配置 配置文件 cd ~ mkdir aria2 cd aria2 touch aria2.conf touch aria2.session touch aria2.log aria2.conf配置文件内容，aria2.session是用来存地址的。 ## 文件保存相关 ## # 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置 dir=/home/johnnychan/Downloads # 日志文件 log=/home/johnnychan/aria2/aria2.log # 日志级别 log-level=warn # 检查完整性，默认true check-integrity=true # 启用磁盘缓存 disk-cache=32M # 断点续传 continue=true # 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc # 预分配所需时间: none \u003c falloc ? trunc \u003c prealloc # falloc和trunc则需要文件系统和内核支持 # NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 file-allocation=trunc ## 进度保存相关 ## # 从会话文件中读取下载任务 input-file=/home/johnnychan/aria2/aria2.session # 在Aria2退出时保存`错误/未完成`的下载任务到会话文件 save-session=/home/johnnychan/aria2/aria2.session # 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 save-session-interval=60 # 下载设置 # 最大同时下载任务数, 运行时可修改, 默认:5 max-concurrent-downloads=10 # 同一服务器连接数, 添加时可指定, 默认:1 max-connection-per-server=10 # 单个任务最大线程数, 添加时可指定, 默认:5 split=5 # 整体下载速度限制, 运行时可修改, 默认:0 max-overall-download-limit=","date":"2020-01-31","objectID":"/manjaro/:4:5","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"开发软件 网络工具 $ sudo pacman -S wireshark-qt # 抓包工具 $ sudo pacman -S bind-tools #Dig（Domain Information Groper）是一个功能强大的命令行工具，用于查询DNS名称服务器 jdk 手动安装oracle-jdk，可选择低版本,下载tar包 解压 tar -zxvf xxx.tar.gz 移动到 /usr/src目录下 sudo mv xxx /usr/src/ 先试一下前面这个，不行再加上后面那个 vim ~/.bashrc 在后面加上， 地址根据jdk修改 export JAVA_HOME=/home/johnnychan/Public/programs/java/jdk8/jdk1.8.0_241 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 启用配置 source .bashrc 查看是否配置成功 java -version 显示 java version \"1.8.0_241\" Java(TM) SE Runtime Environment (build 1.8.0_241-b07) Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode) 前面那个不行在加上底下这个配置jdk环境变量 修改配置文件/etc/profile setting for jdk-oracle JAVA_HOME=/home/johnnychan/Public/programs/java/jdk8/jdk1.8.0_241 CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 启用配置 source /etc/profile Tomcat安裝配置 到Tomcat官网选择相应版本的tar.gz包下载 解压并移动到opt目录下 $ tar -zxvf apache-tomcat-8.5.53.tar.gz sudo cp -r apache-tomcat-8.5.53 /opt/ 发现没有读写查权限，于是开放tomcat及其子目录的权限，-R表示启动递归处理 $ sudo chmod -R 755 /opt/apache-tomcat-8.5.53 启动Tomcat sudo /opt/apache-tomcat-8.5.53/bin/startup.sh 会看到控制台有以下输出： Using CATALINA_BASE: /opt/apache-tomcat-8.5.53 Using CATALINA_HOME: /opt/apache-tomcat-8.5.53 Using CATALINA_TMPDIR: /opt/apache-tomcat-8.5.53/temp Using JRE_HOME: /home/johnnychan/Public/programs/java/jdk8/jdk1.8.0_241/jre Using CLASSPATH: /opt/apache-tomcat-8.5.53/bin/bootstrap.jar:/opt/apache-tomcat-8.5.53/bin/tomcat-juli.jar Tomcat started. 在浏览器地址栏输入http://localhost:8080/ 出现了那幅经典的猫图,成功。 Tomcat 默认运行在8080端口 $ sudo netstat -anpt |grep :8080 tcp 0 0 :::8080 :::* LISTEN 3318/java 关闭Tomcat $ sudo /opt/apache-tomcat-8.5.53/bin/shutdown.sh 或者直接kill进程号,例如: $ sudo kill -9 3318 为了以后方便启动tomcat 可设置软链接 sudo ln -s /opt/apache-tomcat-8.5.53/bin/startup.sh /usr/bin/tomcatup sudo ln -s /opt/apache-tomcat-8.5.53/bin/shutdown.sh /usr/bin/tomcatdown 以后直接使用 sudo tomcatup 和sudo tomcatup即可。 Maven安裝配置 在/usr/local/lib 目录下新建一个文件夹maven： sudo mkdir /usr/local/lib/maven 将文件解压到这个目录下： $ tar -zxvf apache-maven-3.6.3-bin.tar.gz -C /usr/local/lib/maven 也可以放到别的路径下，可以看一下linux目录一般存放规则：http://blog.csdn.net/fuzhongyu2/article/details/52437161 配置环境变量 环境变量分为用户变量和系统变量。 用户变量配置文件：~/.bashrc（在当前用户主目录下的隐藏文件，可以通过ls -a查看到) 系统环境配置文件：/etc/profile 用户变量和系统变量的配置方法一样，本文以配置用户变量为例。 编译配置文件.bashrc: 在终端输入: sudo nano ~/.bashrc 在打开的文档末输入： export MAVEN_HOME=/usr/local/lib/maven/apache-maven-3.6.3 export PATH=${MAVEN_HOME}/bin:${PATH} 点击保存，这样maven环境变量就配置好了。 执行命令: source ~/.bashrc source /etc/profile 测试是否安装成功 输入： mvn -v 如果出现下列字样，则安装成功： Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f) Maven home: /usr/local/lib/maven/apache-maven-3.6.3 Java version: 1.8.0_241, vendor: Oracle Corporation,runtime:/home/johnnychan/Public/programs/java/jdk8/jdk1.8.0_241/jre Default locale: zh_CN, platform encoding: UTF-8 OS name: \"linux\", version: \"5.4.13-3-manjaro\", arch: \"amd64\", family: \"unix\" Git sudo pacman -S git Vim sudo pacman -S vim Vim右键不能粘贴的解决办法 修改/usr/share/vim/vim81/defaults.vim文件，不同发行版位置可能位置不一样， find /usr/ -type f -name 'defaults.vim' 发现我的是/usr/share/vim/vim81/defaults.vim这个文件 sudo vim /usr/share/vim/vim81/defaults.vim 大概在第70多行的地方: if has('mouse') set mouse=a endif 把set mouse=a修改为set mouse-=a if has('mouse') set mouse-=a endif :wq保存退出即可。 Markdown编辑器 sudo pacman -S typora VSCode sudo pacman -S visual-studio-code-bin REST工具 sudo pacman -S postman-bin GIT管理工具 sudo pacman -S gitkraken idea(JAVA IDE) sudo pacman -S intellij-idea-ultimate-edition 数据库管理工具 sudo pacman -S datagrip sudo pacman -S dbeaver 离线API文档管理 sudo pacman -S zeal NodeJS与NPM cd /usr/local/ sudo mkdir node cd node #下载\u0026解压 sudo wget https://nodejs.org/dist/v12.14.1/node-v12.14.1-linux-x64.tar.xz \u0026\u0026 sudo tar zxvf node-v12.14.1-linux-x64.tar.xz #设置全局 sudo ln -s /usr/local/node/node-v12.14.1-linux-x64/bin/node /usr/local/bin/node sudo ln -s /usr/local/node/node-v12.14.1-linux-x64/bin/npm /usr/local/bin/npm #安装cnpm sudo npm install -g cn","date":"2020-01-31","objectID":"/manjaro/:4:6","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"终端软件 sudo pacman -S neofetch # 终端打印出你的系统信息 sudo pacman -S htop #命令行显示进程信息 sudo pacman -S bashtop #终端Linux资源监控器 sudo pacman -S yakuake # 堪称 KDE 下的终端神器，KDE 已经自带，F12 可以唤醒 sudo pacman -S net-tools # 这样可以使用 ifconfig 和 netstat yay -S tree yay -S qrcp #电脑手机通过wifi互传文件工具 上述工具中bashtop和qrcp是GitHub上的开源项目。 ZSH和Oh-my-zsh sudo pacman -S zsh 接着配置oh-my-zsh： sh -c“$（curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh）” 查看本地有哪些shell cat /etc/shells 最后更换默认的shell为zsh： chsh -s /bin/zsh 更改zsh主题 vim ~/.zshrc 修改配置文件中的 \" ZSH_THEME “,例如设置为随机主题 ZSH_THEME = \"random\" 设置为powerlevel10k主题 推荐使用powerlevel10k主题,兼容powerlevel9k，10-100倍的性能提升。 由于使用的是Oh My Zsh，所以只需要将 github 上的 repo 下载到 Oh My Zsh 的目录下然后配置即可。 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k # 然后设置 .zshrc 中的变量 ZSH_THEME ZSH_THEME=\"powerlevel10k/powerlevel10k\" 安装字体 安装完 powerlevel10k 后你可能会发现有乱码，这是因为你终端字体不支持那么多的字符，这就需要使用扩展字体了。 字体的安装，我们可以参考 powerlevel9k 的官方介绍： 安装 powerline 字体有四种方式： Option 1: Install Powerline Fonts 请看官方文档 Option 2: Use a Programmer Font 请看官方文档 Option 3: Install Awesome-Powerline Fonts 请看官方文档 Option 4: Install Nerd-Fonts:Nerd 字体应该是支持字形最多的，所以不用多想，安装它就好了。 GitHub 上有Nerd-Fonts详细的安装介绍文档 可以直接 nerdfonts官网，找到Downloads，直接下载 Hack 字体，，直接双击安装下载的字体即可，然后修改 oh my zsh 的变量文件 ~/.zshrc，在设置主题的配置前添加一行设置： + POWERLEVEL9K_MODE='nerdfont-complete' ZSH_THEME=\"powerlevel10k/powerlevel10k\" ArchLinux下可以运行命令安装: $ sudo pacman -S nerd-fonts-hack **注意：**zsh安装powerlevel10k主题后启动终端会让用户选择各种配置，之后生成相应的配置文件，并在~/.zshrc文件中加入运行该主题自定义配置文件的命令[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh，会在其中看到已经配置了主题的字体typeset -g POWERLEVEL9K_MODE=nerdfont-complete，因此在~/.zshrc中不用再额外设置POWERLEVEL9K_MODE字段。 最后，如果字体没有生效，那就需要手动在系统设置-\u003e字体-\u003e等宽字体中设置Hack字体了。如下图： zsh必备插件安装 参数补全插件 zsh-completions git clone https://github.com/zsh-users/zsh-completions ~/.oh-my-zsh/custom/plugins/zsh-completions 语法高亮插件 zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting 命令自动补全插件 zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions thefuck插件 pip install thefuck fzf，模糊搜索神器 sudo pacman -S fzf 自动跳转插件 autojump 在终端输入d，可以显示刚刚走过的路径，然后按数字选择进入哪一个目录。（这个插件需要自己下) # clone 到本地 git clone git://github.com/joelthelion/autojump.git # 进入clone目录，接着执行安装文件 cd autojump ./install.py # 接着根据安装完成后的提示，在~/.bashrc最后添加下面语句： vim ~/.bashrc [[ -s /home/misfit/.autojump/etc/profile.d/autojump.sh ]] \u0026\u0026 source /home/misfit/.autojump/etc/profile.d/autojump.sh autojump 工作原理：它会在你每次启动命令时记录你当前位置，并把它添加进它自身的数据库中。这样，某些目录比其它一些目录添加的次数多，这些目录一般就代表你最重要的目录，而它们的“权重”也会增大。 安装完后启用插件 # 编辑~/.zshrc vim ~/.zshrc # 在plugins后括号里添加安装的插件名字 plugins=( git zsh-completions autojump zsh-completions zsh-autosuggestions zsh-syntax-highlighting docker docker-compose fzf ) # 最后刷新使配置生效 autoload -U compinit \u0026\u0026 compinit source ~/.zshrc 配置环境变量使得zsh和bash都生效 为了便于在bash和zsh切换后可以使用同样的配置的alias等配置，采用如下方案： 自定义配置放在.profile中 .bashrc配置文件中使用source ~/.profile加载自定义配置 .zshrc配置文件中使用[[ -e ~/.profile ]] \u0026\u0026 emulate sh -c ‘source ~/.profile’加载自定义配置 配置文件示例如下： 在.bashrc原有配置最下面新加一行配置 source ~/.profile .在zshrc原有配置最下面新加一行配置 [[ -e ~/.profile ]] \u0026\u0026 emulate sh -c 'source ~/.profile' .profile export EDITOR=/usr/bin/nano # oh-my-zsh autojump配置 [[ -s /home/misfit/.autojump/etc/profile.d/autojump.sh ]] \u0026\u0026 source /home/misfit/.autojump/etc/profile.d/autojump.sh # 在后面加上地址,根据你jdk配置 # 配置Maven环境变量 然后执行: $ source ~/.profile 在bash终端执行: $ source ~/.bashrc 在zsh终端执行: $ source ~/.zshrc 这样把算定义配置放在.profile里，即可在bash和zsh中使用同样的自定义环境了。 ","date":"2020-01-31","objectID":"/manjaro/:4:7","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"科学上网 Shadowsocks客户端 先用manjaro自带的octopi搜索shadowsocks-qt5，然后安装 安装成功并配置好你自己的ss后，如下: 此时进入系统设置-代理下配置已经连接上的代理端口，如下图: 此时，Chrome浏览器就可以科学上网了，但这是全局的设置，而且没有规则绕过一些国内的网址，因此还要继续设置。 打开Chrome网上应用商店-搜索安装Proxy SwitchyOmega扩展 然后设置一个proxy 再新建设置一个auto switch,规则列表填写地址https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt ，点击立即更新情景模式，按照如下配置: 把这个auto switch情景模式设置为插件默认的就可以了，实现按照规则科学上网，这里是符合规则内的才翻墙，规则之外的直连访问。记得改回系统刚才设置的全局代理。 V2Ray客户端 运行官方一键安装脚本: $ bash \u003c(curl -L -s https://install.direct/go.sh) 或者使用Manjaro自带的包管理器安装 sudo pacman -S v2ray 编辑/etc/v2ray/config.json文件，可以用配置生成器 ArchLinux下的v2ray/config.json 使用v2ray自带了一个检查工具v2ray -test检查json文件 $ v2ray -test -config /etc/v2ray/config.json` #检查json V2Ray 4.22.1 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.13.5 linux/amd64) A unified platform for anti-censorship. Configuration OK. 显示OK就表示没问题了，可以开启本机的开机自启服务 systemctl enable v2ray #开机自启v2ray systemctl start v2ray #启动v2ray 浏览器代理实现同上的shaodowsocks方式。 终端代理 为了解决终端下载被墙服务器的安装包失败的问题，所以需要让终端也可以翻墙，顺便提升下载速度。工具有polipo 和 privoxy 两种,polipo 貌似只能全局代理，privoxy 全局/自动两种代理方式都可以实现。全局代理下，访问 localhost 时也会走代理，可能导致无法正常访问本地服务。 privoxy 实现全局和自动代理 privoxy 可以配置 .action 格式的代理规则文件。通过控制规则文件实现全局和自动代理。 action 文件可以手动编辑，也可以从 gfwlist 生成。 下面将先介绍 privoxy 的安装配置，再介绍 action 文件的生成。 安装配置 安装 privoxy： $ yay -S privoxy 进入目录 /etc/privoxy，可以看到目录结构大致为： config 配置文件，这个文件很长。。 *.action 代理规则文件 *.filter 过滤规则文件 trust 不造干嘛用 templates/ 同上 开始修改配置文件。 privoxy 有 filter （过滤）的功能，可以用来实现广告拦截。不过这里只希望实现自动代理，在配置文件中把 filter 部分注释掉： # 大约在435行 # filterfile default.filter # filterfile user.filter # User customizations 我们将使用自定义的 action 文件，所以把默认的 action 文件注释掉，并添加自定义文件： # 386行左右 # 默认的 action 文件 # actionsfile match-all.action # Actions that are applied to all sites and maybe overruled later on. # actionsfile default.action # Main actions file # actionsfile user.action # User customizations # 自定义 action 文件 actionsfile my.action 可以指定转换后的 HTTP 代理地址，这里直接使用默认端口 8118： # 785行左右 listen-address 127.0.0.1:8118 listen-address [::1]:8118 如果代理规则直接写在配置文件 config 中，那么代理规则和本地 SS 代理地址是写在一起的： # / 代表匹配全部 URL，即全局代理 forward-socks5 / 127.0.0.1:1081 . 或 # 根据规则自动代理 forward-socks5 .google.com 127.0.0.1:1081 . 注意！每行最后还有一个点。 实现全局代理就是第一种写法了。 但是如果要自动代理，第二种直接写在配置文件里的做法其实不太合适，更合适的做法是写成 action 文件，配置文件中只管引用。 把上面的注释掉。 新建 action 文件 my.action，内容如下： # 这一行表示本 action 文件中所有条目都使用代理 {+forward-override{forward-socks5 127.0.0.1:1081 .}} # 添加一条规则 .google.com 把 privoxy 转换后的地址 http://127.0.0.1:8118 添加到环境变量，可以参照 polipo 部分。 启动 privoxy，这时应该可以正常访问 Google 了： service privoxy start curl www.google.com 下面看一下怎么用 gfwlist 生成 action 文件。 生成 action 文件 配置文件 config 或 action 文件修改后不需要重启 privoxy。 使用的工具是 gfwlist2privoxy。这个工具很简单，文档就几行，写得也很清楚。 安装： pip install gfwlist2privoxy gfwlist2privoxy 不支持 python3.x，安装时注意使用的是 pip2 还是 pip3。 参数说明： -i/--input 输入，本地 gfwlist 文件或文件 URL。这里使用上面的 gfwlist -f/ --file 输出，即生成的 action 文件的目录。这里输出到 /etc/privoxy/gfwlist.action -p/ --proxy SS 代理地址，生成后可以修改。这里是 127.0.0.1:1081 -t/ --type 代理类型，生成后也可以修改。这里是 socks5 --user-rule 用户自定义规则文件，这个文件中的规则会被追加到 gfwlist 生成的规则后面 示例： gfwlist2privoxy -i https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt -f /etc/privoxy/gfwlist.action -p 127.0.0.1:1081 -t socks5 得到文件 /etc/privoxy/gfwlist.action,下载地址。 最后，把 /etc/privoxy/config 中的actionsfile my.action 改为 actionsfile gfwlist.action就完成了。 启动 privoxy.service 服务 systemctl start privoxy.service systemctl -l status privoxy.service 配置环境变量 在~/.bashrc或者~/.zshrc中输入 export https_proxy=127.0.0.1:8118 export http_proxy=127.0.0.1:8118 这样就完成代理的设置了。 ","date":"2020-01-31","objectID":"/manjaro/:4:8","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"KDE ","date":"2020-01-31","objectID":"/manjaro/:5:0","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"KDE插件 Resource Monitor（系统资源监控）： yay -S plasma5-applets-resources-monitor Netspeed Widget（网络监控）： yay -S plasma5-applets-netspeed Latte Dock： sudo pacman -S latte-dock Global Menu 可以访问https://store.kde.org/ 找插件，或者在AUR包的网站上根据插件名找是否有相应的包安装。 ","date":"2020-01-31","objectID":"/manjaro/:5:1","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"KDE设置 一些桌面设置： 显示： 屏幕 120% 放大： 系统设置 \u003e 显示 \u003e 全局缩放\u003e 1.2 全局菜单： 因为有了 Latte Dock，不再需要任务栏了，取而代之的是全局菜单。需要添加全局菜单的桌面部件 sudo pacman -S appmenu-gtk-module sudo pacman -S libdbusmenu-glib # For electron apps menu 锁屏： 系统设置 \u003e 工作空间行为 \u003e 锁屏 \u003e 键盘快捷键 设为 Meta + L 。 KDE 桌面动画： 系统设置 \u003e 工作空间行为 \u003e 桌面特效 设置你喜欢的桌面效果。 打开文件： KDE 默认是单击打开文件，需要修改成跟Window一样的话： 系统设置 \u003e 工作空间行为 \u003e 常规行为 \u003e 点击行为 一些命令与技巧 ","date":"2020-01-31","objectID":"/manjaro/:5:2","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"常用pacman命令 ","date":"2020-01-31","objectID":"/manjaro/:6:0","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"更新系统 在 Archlinux系 中，使用一条命令即可对整个系统进行更新: $ pacman -Syu 如果你已经使用pacman -Sy将本地的包数据库与远程的仓库进行了同步，也可以只执行: $ pacman -Su ","date":"2020-01-31","objectID":"/manjaro/:6:1","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"安装包 pacman -S 包名：例如，执行 pacman -S firefox 将安装 Firefox 你也可以同时安装多个包，只需以空格分隔包名即可 pacman -Sy 包名：与上面命令不同的是，该命令将在同步包数据库后再执行安装 pacman -Sv 包名：在显示一些操作信息后执行安装 pacman -U：安装本地包，其扩展名为 pkg.tar.gz pacman -U http://www.example.com/repo/example.pkg.tar.xz 安装一个远程包（不在pacman配置的源里面） ","date":"2020-01-31","objectID":"/manjaro/:6:2","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"删除包 pacman -R 包名：该命令将只删除包，保留其全部已经安装的依赖关系 pacman -Rs 包名：在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖 pacman -Rsc 包名：在删除包的同时，删除所有依赖这个软件包的程序 pacman -Rd 包名：在删除包时不检查依赖 ","date":"2020-01-31","objectID":"/manjaro/:6:3","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"搜索包 pacman -Ss 关键字：在仓库中搜索含关键字的包 pacman -Qs 关键字： 搜索已安装的包 pacman -Qi 包名：查看有关包的详尽信息 pacman -Ql 包名：列出该包的文件 ","date":"2020-01-31","objectID":"/manjaro/:6:4","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"其他用法 pacman -Sw 包名：只下载包，不安装 pacman -Sc：清理未安装的包文件，包文件位于/var/cache/pacman/pkg/目录 pacman -Scc：清理所有的缓存文件 ","date":"2020-01-31","objectID":"/manjaro/:6:5","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"pacman替代命令yay sudo pacman -S yay yay 的命令参数跟pacman参数基本一致。 ","date":"2020-01-31","objectID":"/manjaro/:6:6","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"常用命令 ","date":"2020-01-31","objectID":"/manjaro/:7:0","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"查看网卡信息 $ lspci|grep -i net ","date":"2020-01-31","objectID":"/manjaro/:7:1","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"查看已经启用的服务 systemctl list-unit-files --state=enabled ","date":"2020-01-31","objectID":"/manjaro/:7:2","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"查看关联性服务启动耗费时间 systemd-analyze critical-chain xxx.service ","date":"2020-01-31","objectID":"/manjaro/:7:3","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"按时间排序，查看服务启动耗费时间 systemd-analyze blame ","date":"2020-01-31","objectID":"/manjaro/:7:4","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"GIT代理设置 推荐放到 .zshrc 中作为常用命令 git-proxy(){ git config --global http.proxy socks5://127.0.0.1:1080 git config --global https.proxy socks5://127.0.0.1:1080 } git-noproxy(){ git config --global --unset http.proxy git config --global --unset https.proxy } ","date":"2020-01-31","objectID":"/manjaro/:7:5","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"一些小技巧 ","date":"2020-01-31","objectID":"/manjaro/:8:0","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"快捷键 F12：拉幕式终端 Alt+空格：调出全局搜索 Ctrl+F8：切出多桌面窗口 ","date":"2020-01-31","objectID":"/manjaro/:8:1","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"},{"categories":["技术","Manjaro"],"content":"鼠标操作 在左上角撮几下，平铺所有窗口。 鼠标滚轮好慢： sudo pacman -S imwheel #配置文件自己上网查 参考链接 Manjaro 安装体验小结 Manjaro的尝试 Manjaro安装，配置，美化指南 Manjaro Linux 踩坑调教记录 Manjaro常用软件和命令行推荐 polipo/privoxy 实现 Linux 系统全局/自动代理 centos privoxy action 分流，黑白名单，不走代理 学习利器V2ray了解一下 Linux bash终端设置代理(proxy)访问 Linux-zsh与bash共用 Manjaro中文输入法安装 比较几种中文输入法后，我最终选择了sunpinyin + cloudpinyin组合 manjaro xfce 18.0 踩坑记录 将干净的 Manjaro 快速配置为工作环境 记录一次linux系统迁移过程 manjaro踩坑记 在Manjaro Linux下安装驱动程序的两种方法 Tesseract:安装与命令行使用 linux 环境下安装tesseract 提取图片文字——linux下tesseract-ocr安装编译 Fcitx (简体中文) 在Manjaro上优雅地使用Fcitx5 尝试Fcitx5 ","date":"2020-01-31","objectID":"/manjaro/:8:2","tags":["Manjaro安装和配置"],"title":"Manjaro安装调教","uri":"/manjaro/"}]